(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[7],{

/***/ "./node_modules/@vuelidate/core/dist/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@vuelidate/core/dist/index.esm.js ***!
  \********************************************************/
/*! exports provided: default, CollectFlag, useVuelidate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CollectFlag\", function() { return CollectFlag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useVuelidate\", function() { return useVuelidate; });\n/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ \"./node_modules/vue-demi/lib/index.esm.js\");\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction unwrapObj(obj) {\n  var ignoreKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return Object.keys(obj).reduce(function (o, k) {\n    if (ignoreKeys.includes(k)) return o;\n    o[k] = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(obj[k]);\n    return o;\n  }, {});\n}\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isProxy(value) {\n  return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isReactive\"])(value) || Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isReadonly\"])(value);\n}\n\nfunction _call(body, then, direct) {\n  if (direct) {\n    return then ? then(body()) : body();\n  }\n\n  try {\n    var result = Promise.resolve(body());\n    return then ? result.then(then) : result;\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\nvar ROOT_PATH = '__root';\n/**\n * @typedef {import('vue-demi').ComponentPublicInstance} VueInstance\n */\n\n/**\n * @typedef {import('vue-demi').ComputedRef} ComputedRef\n */\n\n/**\n * @typedef {import('vue-demi').WatchStopHandle} WatchStopHandle\n */\n\n/**\n * @typedef NormalizedValidator\n * @property {Validator} $validator\n * @property {String | Ref<String> | function(*): string} [$message]\n * @property {Object | Ref<Object>} [$params]\n * @property {Object | Ref<Object>} [$async]\n * @property {Ref<*>[]} [$watchTargets]\n */\n\n/**\n * Response form a raw Validator function.\n * Should return a Boolean or an object with $invalid property.\n * @typedef {Boolean | { $valid: Boolean }} ValidatorResponse\n */\n\n/**\n * Raw validator function, before being normalized\n * Can return a Promise or a {@see ValidatorResponse}\n * @typedef {function(*): ((Promise<ValidatorResponse> | ValidatorResponse))} Validator\n */\n\n/**\n * Sorts the validators for a state tree branch\n * @param {Object<NormalizedValidator|Function>} validationsRaw\n * @return {{ rules: Object<NormalizedValidator>, nestedValidators: Object, config: GlobalConfig }}\n */\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n/**\n * Calls a validation rule by unwrapping its value first from a ref.\n * @param {Validator} rule\n * @param {Ref} value\n * @param {VueInstance} instance\n * @return {Promise<ValidatorResponse> | ValidatorResponse}\n */\n\n\nfunction sortValidations() {\n  var validationsRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var validations = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(validationsRaw);\n  var validationKeys = Object.keys(validations);\n  var rules = {};\n  var nestedValidators = {};\n  var config = {};\n  validationKeys.forEach(function (key) {\n    var v = validations[key];\n\n    switch (true) {\n      // If it is already normalized, use it\n      case isFunction(v.$validator):\n        rules[key] = v;\n        break;\n      // If it is just a function, normalize it first\n      // into { $validator: <Fun> }\n\n      case isFunction(v):\n        rules[key] = {\n          $validator: v\n        };\n        break;\n      // Catch $-prefixed properties as config\n\n      case key.startsWith('$'):\n        config[key] = v;\n        break;\n      // If it doesn’t match any of the above,\n      // treat as nestedValidators state property\n\n      default:\n        nestedValidators[key] = v;\n    }\n  });\n  return {\n    rules: rules,\n    nestedValidators: nestedValidators,\n    config: config\n  };\n}\n\nfunction callRule(rule, value, instance) {\n  var v = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(value);\n  return rule.call(instance, v, instance);\n}\n/**\n * Normalizes the validator result\n * Allows passing a boolean of an object like `{ $valid: Boolean }`\n * @param {ValidatorResponse} result - Validator result\n * @return {boolean}\n */\n\n\nfunction normalizeValidatorResponse(result) {\n  return result.$valid !== undefined ? !result.$valid : !result;\n}\n/**\n * Returns the result of an async validator.\n * @param {Validator} rule\n * @param {Ref<*>} model\n * @param {Ref<Boolean>} $pending\n * @param {Ref<Boolean>} $dirty\n * @param {GlobalConfig} config\n * @param {boolean} config.$lazy\n * @param {Ref<*>} $response\n * @param {VueInstance} instance\n * @param {Ref<*>[]} watchTargets\n * @return {{ $invalid: Ref<Boolean>, $unwatch: WatchStopHandle }}\n */\n\n\nfunction createAsyncResult(rule, model, $pending, $dirty, _ref, $response, instance) {\n  var $lazy = _ref.$lazy;\n  var watchTargets = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [];\n  var $invalid = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(!!$dirty.value);\n  var $pendingCounter = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(0);\n  $pending.value = false;\n  var $unwatch = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])([model, $dirty].concat(watchTargets), function () {\n    if ($lazy && !$dirty.value) return false;\n    var ruleResult; // make sure we dont break if a validator throws\n\n    try {\n      ruleResult = callRule(rule, model, instance);\n    } catch (err) {\n      // convert to a promise, so we can handle it async\n      ruleResult = Promise.reject(err);\n    }\n\n    $pendingCounter.value++;\n    $pending.value = !!$pendingCounter.value;\n    $invalid.value = true;\n    Promise.resolve(ruleResult).then(function (data) {\n      $pendingCounter.value--;\n      $pending.value = !!$pendingCounter.value;\n      $response.value = data;\n      $invalid.value = normalizeValidatorResponse(data);\n    })[\"catch\"](function (error) {\n      $pendingCounter.value--;\n      $pending.value = !!$pendingCounter.value;\n      $response.value = error;\n      $invalid.value = true;\n    });\n  }, {\n    immediate: true,\n    deep: _typeof(model) === 'object'\n  });\n  return {\n    $invalid: $invalid,\n    $unwatch: $unwatch\n  };\n}\n/**\n * Returns the result of a sync validator\n * @param {Validator} rule\n * @param {Ref<*>} model\n * @param {Ref<Boolean>} $dirty\n * @param {GlobalConfig} config\n * @param {Boolean} config.$lazy\n * @param {Ref<*>} $response\n * @param {VueInstance} instance\n * @return {{$unwatch: (function(): {}), $invalid: ComputedRef<boolean>}}\n */\n\n\nfunction createSyncResult(rule, model, $dirty, _ref2, $response, instance) {\n  var $lazy = _ref2.$lazy;\n\n  var $unwatch = function $unwatch() {\n    return {};\n  };\n\n  var $invalid = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    if ($lazy && !$dirty.value) return false;\n\n    try {\n      var result = callRule(rule, model, instance);\n      $response.value = result;\n      return normalizeValidatorResponse(result);\n    } catch (err) {\n      $response.value = err;\n    }\n\n    return true;\n  });\n  return {\n    $unwatch: $unwatch,\n    $invalid: $invalid\n  };\n}\n/**\n * Returns the validation result.\n * Detects async and sync validators.\n * @param {NormalizedValidator} rule\n * @param {Ref<*>} model\n * @param {Ref<boolean>} $dirty\n * @param {GlobalConfig} config - Vuelidate config\n * @param {VueInstance} instance - component instance\n * @param {string} validatorName - name of the current validator\n * @param {string} propertyKey - the current property we are validating\n * @param {string} propertyPath - the deep path to the validated property\n * @return {{ $params: *, $message: Ref<String>, $pending: Ref<Boolean>, $invalid: Ref<Boolean>, $response: Ref<*>, $unwatch: WatchStopHandle }}\n */\n\n\nfunction createValidatorResult(rule, model, $dirty, config, instance, validatorName, propertyKey, propertyPath) {\n  var $pending = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(false);\n  var $params = rule.$params || {};\n  var $response = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(null);\n  var $invalid;\n  var $unwatch;\n\n  if (rule.$async) {\n    var _createAsyncResult = createAsyncResult(rule.$validator, model, $pending, $dirty, config, $response, instance, rule.$watchTargets);\n\n    $invalid = _createAsyncResult.$invalid;\n    $unwatch = _createAsyncResult.$unwatch;\n  } else {\n    var _createSyncResult = createSyncResult(rule.$validator, model, $dirty, config, $response, instance);\n\n    $invalid = _createSyncResult.$invalid;\n    $unwatch = _createSyncResult.$unwatch;\n  }\n\n  var message = rule.$message;\n  var $message = isFunction(message) ? Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return message(unwrapObj({\n      $pending: $pending,\n      $invalid: $invalid,\n      $params: unwrapObj($params),\n      // $params can hold refs, so we unwrap them for easy access\n      $model: model,\n      $response: $response,\n      $validator: validatorName,\n      $propertyPath: propertyPath,\n      $property: propertyKey\n    }));\n  }) : message || '';\n  return {\n    $message: $message,\n    $params: $params,\n    $pending: $pending,\n    $invalid: $invalid,\n    $response: $response,\n    $unwatch: $unwatch\n  };\n}\n/**\n * @typedef ErrorObject\n * @property {Ref<String>} $message - Reactive error message\n * @property {Ref<Object>} $params - Params passed from withParams\n * @property {Ref<Boolean>} $pending - If validation is pending\n * @property {String} $property - State key\n * @property {String} $propertyPath - Dot notation path to state\n * @property {String} $validator - Validator name\n * @property {String} $uid - Unique identifier\n */\n\n/**\n * @typedef ValidationResult\n * @property {Ref<Boolean>} $pending\n * @property {Ref<Boolean>} $dirty\n * @property {Ref<Boolean>} $invalid\n * @property {Ref<Boolean>} $error\n * @property {Ref<String>} $path\n * @property {Function} $touch\n * @property {Function} $reset\n * @property {ComputedRef<ErrorObject[]>} $errors\n * @property {ComputedRef<ErrorObject[]>} $silentErrors\n */\n\n/**\n * Creates the main Validation Results object for a state tree\n * Walks the tree's top level branches\n * @param {Object<NormalizedValidator>} rules - Rules for the current state tree\n * @param {Object} model - Current state value\n * @param {String} key - Key for the current state tree\n * @param {ResultsStorage} [resultsCache] - A cache map of all the validators\n * @param {String} [path] - the current property path\n * @param {GlobalConfig} [config] - the config object\n * @param {VueInstance} instance\n * @param {ComputedRef<Object>} externalResults\n * @return {ValidationResult | {}}\n */\n\n\nfunction createValidationResults(rules, model, key, resultsCache, path, config, instance, externalResults) {\n  // collect the property keys\n  var ruleKeys = Object.keys(rules);\n  var cachedResult = resultsCache.get(path, rules);\n  var $dirty = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])(false);\n\n  if (cachedResult) {\n    // if the rules are the same as before, use the cached results\n    if (!cachedResult.$partial) return cachedResult; // remove old watchers\n\n    cachedResult.$unwatch(); // use the `$dirty.value`, so we dont save references by accident\n\n    $dirty.value = cachedResult.$dirty.value;\n  }\n\n  var result = {\n    // restore $dirty from cache\n    $dirty: $dirty,\n    $path: path,\n    $touch: function $touch() {\n      if (!$dirty.value) $dirty.value = true;\n    },\n    $reset: function $reset() {\n      if ($dirty.value) $dirty.value = false;\n    }\n  };\n  /**\n   * If there are no validation rules, it is most likely\n   * a top level state, aka root\n   */\n\n  if (!ruleKeys.length) {\n    // if there are cached results, we should overwrite them with the new ones\n    cachedResult && resultsCache.set(path, rules, result);\n    return result;\n  }\n\n  ruleKeys.forEach(function (ruleKey) {\n    result[ruleKey] = createValidatorResult(rules[ruleKey], model, result.$dirty, config, instance, ruleKey, key, path);\n  });\n  result.$externalResults = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    if (!externalResults.value) return [];\n    return [].concat(externalResults.value).map(function (stringError, index) {\n      return {\n        $propertyPath: path,\n        $property: key,\n        $validator: '$externalResults',\n        $uid: \"\".concat(path, \"-\").concat(index),\n        $message: stringError,\n        $params: {},\n        $response: null,\n        $pending: false\n      };\n    });\n  });\n  result.$invalid = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return !!result.$externalResults.value.length || ruleKeys.some(function (ruleKey) {\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(result[ruleKey].$invalid);\n    });\n  });\n  result.$pending = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return ruleKeys.some(function (ruleKey) {\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(result[ruleKey].$pending);\n    });\n  });\n  result.$error = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return result.$invalid.value && result.$dirty.value;\n  });\n  result.$silentErrors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return ruleKeys.filter(function (ruleKey) {\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(result[ruleKey].$invalid);\n    }).map(function (ruleKey) {\n      var res = result[ruleKey];\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])({\n        $propertyPath: path,\n        $property: key,\n        $validator: ruleKey,\n        $uid: \"\".concat(path, \"-\").concat(ruleKey),\n        $message: res.$message,\n        $params: res.$params,\n        $response: res.$response,\n        $pending: res.$pending\n      });\n    }).concat(result.$externalResults.value);\n  });\n  result.$errors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return result.$dirty.value ? result.$silentErrors.value : [];\n  });\n\n  result.$unwatch = function () {\n    return ruleKeys.forEach(function (ruleKey) {\n      result[ruleKey].$unwatch();\n    });\n  };\n\n  resultsCache.set(path, rules, result);\n  return result;\n}\n/**\n * Collects the validation results of all nested state properties\n * @param {Object<NormalizedValidator|Function>} validations - The validation\n * @param {Object} nestedState - Current state\n * @param {String} path - Path to current property\n * @param {ResultsStorage} resultsCache - Validations cache map\n * @param {GlobalConfig} config - The config object\n * @param {VueInstance} instance - The current Vue instance\n * @param {ComputedRef<object>} nestedExternalResults - The external results for this nested collection\n * @return {{}}\n */\n\n\nfunction collectNestedValidationResults(validations, nestedState, path, resultsCache, config, instance, nestedExternalResults) {\n  var nestedValidationKeys = Object.keys(validations); // if we have no state, return empty object\n\n  if (!nestedValidationKeys.length) return {};\n  return nestedValidationKeys.reduce(function (results, nestedKey) {\n    // build validation results for nested state\n    results[nestedKey] = setValidations({\n      validations: validations[nestedKey],\n      state: nestedState,\n      key: nestedKey,\n      parentKey: path,\n      resultsCache: resultsCache,\n      globalConfig: config,\n      instance: instance,\n      externalResults: nestedExternalResults\n    });\n    return results;\n  }, {});\n}\n/**\n * Generates the Meta fields from the results\n * @param {ValidationResult|{}} results\n * @param {Object.<string, ValidationResult>[]} nestedResults\n * @param {Object.<string, ValidationResult>[]} childResults\n * @return {{$anyDirty: Ref<Boolean>, $error: Ref<Boolean>, $invalid: Ref<Boolean>, $errors: Ref<ErrorObject[]>, $dirty: Ref<Boolean>, $touch: Function, $reset: Function }}\n */\n\n\nfunction createMetaFields(results, nestedResults, childResults) {\n  var allResults = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return [nestedResults, childResults].filter(function (res) {\n      return res;\n    }).reduce(function (allRes, res) {\n      return allRes.concat(Object.values(Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(res)));\n    }, []);\n  }); // returns `$dirty` as true, if all children are dirty\n\n  var $dirty = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])({\n    get: function get() {\n      return results.$dirty.value || (allResults.value.length ? allResults.value.every(function (r) {\n        return r.$dirty;\n      }) : false);\n    },\n    set: function set(v) {\n      results.$dirty.value = v;\n    }\n  });\n  var $silentErrors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    // current state level errors, fallback to empty array if root\n    var modelErrors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(results.$silentErrors) || []; // collect all nested and child $silentErrors\n\n    var nestedErrors = allResults.value.filter(function (result) {\n      return (Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(result).$silentErrors || []).length;\n    }).reduce(function (errors, result) {\n      return errors.concat.apply(errors, _toConsumableArray(result.$silentErrors));\n    }, []); // merge the $silentErrors\n\n    return modelErrors.concat(nestedErrors);\n  });\n  var $errors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    // current state level errors, fallback to empty array if root\n    var modelErrors = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(results.$errors) || []; // collect all nested and child $errors\n\n    var nestedErrors = allResults.value.filter(function (result) {\n      return (Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(result).$errors || []).length;\n    }).reduce(function (errors, result) {\n      return errors.concat.apply(errors, _toConsumableArray(result.$errors));\n    }, []); // merge the $errors\n\n    return modelErrors.concat(nestedErrors);\n  });\n  var $invalid = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return (// if any of the nested values is invalid\n      allResults.value.some(function (r) {\n        return r.$invalid;\n      }) || // or if the current state is invalid\n      Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(results.$invalid) || // fallback to false if is root\n      false\n    );\n  });\n  var $pending = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return (// if any of the nested values is pending\n      allResults.value.some(function (r) {\n        return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(r.$pending);\n      }) || // if any of the current state validators is pending\n      Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(results.$pending) || // fallback to false if is root\n      false\n    );\n  });\n  var $anyDirty = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return allResults.value.some(function (r) {\n      return r.$dirty;\n    }) || allResults.value.some(function (r) {\n      return r.$anyDirty;\n    }) || $dirty.value;\n  });\n  var $error = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return $invalid.value && $dirty.value || false;\n  });\n\n  var $touch = function $touch() {\n    // call the root $touch\n    results.$touch(); // call all nested level $touch\n\n    allResults.value.forEach(function (result) {\n      result.$touch();\n    });\n  };\n\n  var $reset = function $reset() {\n    // reset the root $dirty state\n    results.$reset(); // reset all the children $dirty states\n\n    allResults.value.forEach(function (result) {\n      result.$reset();\n    });\n  }; // Ensure that if all child and nested results are $dirty, this also becomes $dirty\n\n\n  if (allResults.value.length && allResults.value.every(function (nr) {\n    return nr.$dirty;\n  })) $touch();\n  return {\n    $dirty: $dirty,\n    $errors: $errors,\n    $invalid: $invalid,\n    $anyDirty: $anyDirty,\n    $error: $error,\n    $pending: $pending,\n    $touch: $touch,\n    $reset: $reset,\n    $silentErrors: $silentErrors\n  };\n}\n/**\n * @typedef VuelidateState\n * @property {WritableComputedRef<any>} $model\n * @property {ComputedRef<Boolean>} $dirty\n * @property {ComputedRef<Boolean>} $error\n * @property {ComputedRef<ErrorObject[]>} $errors\n * @property {ComputedRef<Boolean>} $invalid\n * @property {ComputedRef<Boolean>} $anyDirty\n * @property {ComputedRef<Boolean>} $pending\n * @property {Function} $touch\n * @property {Function} $reset\n * @property {String} $path\n * @property {ComputedRef<ErrorObject[]>} $silentErrors\n * @property {Function} [$validate]\n * @property {Function} [$getResultsForChild]\n * @property {Object.<string, VuelidateState>}\n */\n\n/**\n * Main Vuelidate bootstrap function.\n * Used both for Composition API in `setup` and for Global App usage.\n * Used to collect validation state, when walking recursively down the state tree\n * @param {Object} params\n * @param {Object<NormalizedValidator|Function>} params.validations\n * @param {Object} params.state\n * @param {String} [params.key] - Current state property key. Used when being called on nested items\n * @param {String} [params.parentKey] - Parent state property key. Used when being called recursively\n * @param {Object<ValidationResult>} [params.childResults] - Used to collect child results.\n * @param {ResultsStorage} params.resultsCache - The cached validation results\n * @param {VueInstance} params.instance - The current Vue instance\n * @param {GlobalConfig} params.globalConfig - The validation config, passed to this setValidations instance.\n * @param {Reactive<object> | Ref<Object>} params.externalResults - External validation results\n * @return {UnwrapNestedRefs<VuelidateState>}\n */\n\n\nfunction setValidations(_ref3) {\n  var validations = _ref3.validations,\n      state = _ref3.state,\n      key = _ref3.key,\n      parentKey = _ref3.parentKey,\n      childResults = _ref3.childResults,\n      resultsCache = _ref3.resultsCache,\n      _ref3$globalConfig = _ref3.globalConfig,\n      globalConfig = _ref3$globalConfig === void 0 ? {} : _ref3$globalConfig,\n      instance = _ref3.instance,\n      externalResults = _ref3.externalResults;\n  var path = parentKey ? \"\".concat(parentKey, \".\").concat(key) : key; // Sort out the validation object into:\n  // – rules = validators for current state tree fragment\n  // — nestedValidators = nested state fragments keys that might contain more validators\n  // – config = configuration properties that affect this state fragment\n\n  var _sortValidations = sortValidations(validations),\n      rules = _sortValidations.rules,\n      nestedValidators = _sortValidations.nestedValidators,\n      config = _sortValidations.config;\n\n  var mergedConfig = Object.assign({}, globalConfig, config); // create protected state for cases when the state branch does not exist yet.\n  // This protects when using the OptionsAPI as the data is bound after the setup method\n\n  var nestedState = key ? Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    var s = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(state);\n    return s ? Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(s[key]) : undefined;\n  }) : state; // cache the external results, so we can revert back to them\n\n  var cachedExternalResults = Object.assign({}, Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(externalResults) || {});\n  var nestedExternalResults = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    var results = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(externalResults);\n    if (!key) return results;\n    return results ? Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(results[key]) : undefined;\n  }); // Use rules for the current state fragment and validate it\n\n  var results = createValidationResults(rules, nestedState, key, resultsCache, path, mergedConfig, instance, nestedExternalResults); // Use nested keys to repeat the process\n  // *WARN*: This is recursive\n\n  var nestedResults = collectNestedValidationResults(nestedValidators, nestedState, path, resultsCache, mergedConfig, instance, nestedExternalResults); // Collect and merge this level validation results\n  // with all nested validation results\n\n  var _createMetaFields = createMetaFields(results, nestedResults, childResults),\n      $dirty = _createMetaFields.$dirty,\n      $errors = _createMetaFields.$errors,\n      $invalid = _createMetaFields.$invalid,\n      $anyDirty = _createMetaFields.$anyDirty,\n      $error = _createMetaFields.$error,\n      $pending = _createMetaFields.$pending,\n      $touch = _createMetaFields.$touch,\n      $reset = _createMetaFields.$reset,\n      $silentErrors = _createMetaFields.$silentErrors;\n  /**\n   * If we have no `key`, this is the top level state\n   * We dont need `$model` there.\n   */\n\n\n  var $model = key ? Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])({\n    get: function get() {\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(nestedState);\n    },\n    set: function set(val) {\n      $dirty.value = true;\n      var s = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(state);\n\n      if (Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isRef\"])(s[key])) {\n        s[key].value = val;\n      } else {\n        s[key] = val;\n      }\n    }\n  }) : null;\n\n  if (key && mergedConfig.$autoDirty) {\n    var $unwatch = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(nestedState, function () {\n      var autoDirtyPath = \"_\".concat(path, \"_$watcher_\");\n      var cachedAutoDirty = resultsCache.get(autoDirtyPath, {});\n      if (!$dirty.value) $touch();\n      if (cachedAutoDirty) cachedAutoDirty.$unwatch();\n      resultsCache.set(autoDirtyPath, {}, {\n        $unwatch: $unwatch\n      });\n    }, {\n      flush: 'sync'\n    });\n  }\n  /**\n   * Executes the validators and returns the result.\n   * @return {Promise<boolean>}\n   */\n\n\n  function $validate() {\n    return new Promise(_async(function (resolve) {\n      if (!$dirty.value) $touch(); // await the watchers\n\n      return _call(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"nextTick\"], function () {\n        // return whether it is valid or not\n        if (!$pending.value) return resolve(!$invalid.value);\n        var unwatch = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])($pending, function () {\n          resolve(!$invalid.value);\n          unwatch();\n        });\n      });\n    }));\n  }\n  /**\n   * Returns a child component's results, based on registration name\n   * @param {string} key\n   * @return {VuelidateState}\n   */\n\n\n  function $getResultsForChild(key) {\n    return (childResults.value || {})[key];\n  }\n\n  function $clearExternalResults() {\n    if (Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isRef\"])(externalResults)) {\n      externalResults.value = cachedExternalResults;\n    } else {\n      // if the external results state was empty, we need to delete every property, one by one\n      if (Object.keys(cachedExternalResults).length === 0) {\n        Object.keys(externalResults).forEach(function (k) {\n          delete externalResults[k];\n        });\n      } else {\n        // state was not empty, so we just assign it back into the current state\n        Object.assign(externalResults, cachedExternalResults);\n      }\n    }\n  }\n\n  return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])(Object.assign({}, results, {\n    // NOTE: The order here is very important, since we want to override\n    // some of the *results* meta fields with the collective version of it\n    // that includes the results of nested state validation results\n    $model: $model,\n    $dirty: $dirty,\n    $error: $error,\n    $errors: $errors,\n    $invalid: $invalid,\n    $anyDirty: $anyDirty,\n    $pending: $pending,\n    $touch: $touch,\n    $reset: $reset,\n    $path: path || ROOT_PATH,\n    $silentErrors: $silentErrors\n  }, childResults && {\n    $getResultsForChild: $getResultsForChild,\n    $validate: $validate,\n    $clearExternalResults: $clearExternalResults\n  }, nestedResults));\n}\n\nvar ResultsStorage = /*#__PURE__*/function () {\n  function ResultsStorage() {\n    _classCallCheck(this, ResultsStorage);\n\n    this.storage = new Map();\n  }\n  /**\n   * Stores a validation result, and its rules by its path\n   * @param {String} path\n   * @param {Object<NormalizedValidator>} rules\n   * @param {ValidationResult} result\n   */\n\n\n  _createClass(ResultsStorage, [{\n    key: \"set\",\n    value: function set(path, rules, result) {\n      this.storage.set(path, {\n        rules: rules,\n        result: result\n      });\n    }\n    /**\n     * Check if the stored `results` for the provided `path` have the same `rules` compared to 'storedRules'\n     * @param {String} path\n     * @param {Object<NormalizedValidator>} rules\n     * @param {Object<NormalizedValidator>} storedRules\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"checkRulesValidity\",\n    value: function checkRulesValidity(path, rules, storedRules) {\n      var storedRulesKeys = Object.keys(storedRules);\n      var newRulesKeys = Object.keys(rules);\n      if (newRulesKeys.length !== storedRulesKeys.length) return false;\n      var hasAllValidators = newRulesKeys.every(function (ruleKey) {\n        return storedRulesKeys.includes(ruleKey);\n      });\n      if (!hasAllValidators) return false;\n      return newRulesKeys.every(function (ruleKey) {\n        if (!rules[ruleKey].$params) return true;\n        return Object.keys(rules[ruleKey].$params).every(function (paramKey) {\n          // make sure to unwrap before comparing\n          return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(storedRules[ruleKey].$params[paramKey]) === Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(rules[ruleKey].$params[paramKey]);\n        });\n      });\n    }\n    /**\n     * Returns the matched result if catche is valid\n     * @param {String} path\n     * @param {Object<NormalizedValidator>} rules\n     * @return {{$partial: boolean, $dirty: Ref<boolean>}|undefined|ValidationResult}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(path, rules) {\n      var storedRuleResultPair = this.storage.get(path);\n      if (!storedRuleResultPair) return undefined;\n      var storedRules = storedRuleResultPair.rules,\n          result = storedRuleResultPair.result;\n      var isValidCache = this.checkRulesValidity(path, rules, storedRules);\n      var $unwatch = result.$unwatch ? result.$unwatch : function () {\n        return {};\n      };\n      if (!isValidCache) return {\n        $dirty: result.$dirty,\n        $partial: true,\n        $unwatch: $unwatch\n      };\n      return result;\n    }\n  }]);\n\n  return ResultsStorage;\n}();\n\nvar VuelidateInjectChildResults = Symbol('vuelidate#injectChiildResults');\nvar VuelidateRemoveChildResults = Symbol('vuelidate#removeChiildResults');\nvar CollectFlag = {\n  COLLECT_ALL: true,\n  COLLECT_NONE: false\n};\n/**\n * Create helpers to collect validation state from child components\n * @param {Object} params\n * @param {String | Number} params.$scope - Parent component scope\n * @return {{sendValidationResultsToParent: function, childResults: ComputedRef<Object>, removeValidationResultsFromParent: function}}\n */\n\nfunction nestedValidations(_ref) {\n  var $scope = _ref.$scope;\n  var childResultsRaw = {};\n  var childResultsKeys = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])([]);\n  var childResults = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return childResultsKeys.value.reduce(function (results, key) {\n      results[key] = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(childResultsRaw[key]);\n      return results;\n    }, {});\n  });\n  /**\n   * Allows children to send validation data up to their parent.\n   * @param {Object} results - the results\n   * @param {Object} args\n   * @param {String} args.$registerAs - the $registeredAs key\n   * @param {String | Number} args.$scope - the $scope key\n   */\n\n  function injectChildResultsIntoParent(results, _ref2) {\n    var key = _ref2.$registerAs,\n        childScope = _ref2.$scope,\n        $stopPropagation = _ref2.$stopPropagation;\n    if ($stopPropagation || $scope === CollectFlag.COLLECT_NONE || childScope === CollectFlag.COLLECT_NONE || $scope !== CollectFlag.COLLECT_ALL && $scope !== childScope) return;\n    childResultsRaw[key] = results;\n    childResultsKeys.value.push(key);\n  }\n  /**\n   * Allows children to remove the validation data from their parent, before getting destroyed.\n   * @param {String} key - the registeredAs key\n   */\n\n\n  function removeChildResultsFromParent(key) {\n    // remove the key\n    childResultsKeys.value = childResultsKeys.value.filter(function (childKey) {\n      return childKey !== key;\n    }); // remove the stored data for the key\n\n    delete childResultsRaw[key];\n  } // inject the `injectChildResultsIntoParent` method, into the current scope\n\n\n  var sendValidationResultsToParent = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"inject\"])(VuelidateInjectChildResults, function () {}); // provide to all of its children the send results to parent function\n\n  Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"provide\"])(VuelidateInjectChildResults, injectChildResultsIntoParent);\n  var removeValidationResultsFromParent = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"inject\"])(VuelidateRemoveChildResults, function () {}); // provide to all of its children the remove results  function\n\n  Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"provide\"])(VuelidateRemoveChildResults, removeChildResultsFromParent);\n  return {\n    childResults: childResults,\n    sendValidationResultsToParent: sendValidationResultsToParent,\n    removeValidationResultsFromParent: removeValidationResultsFromParent\n  };\n}\n/**\n * @typedef GlobalConfig\n * @property {String} [$registerAs] - Config Object\n * @property {String | Number | Symbol} [$scope] - A scope to limit child component registration\n * @property {Boolean} [$stopPropagation] - Tells a Vue component to stop sending its results up to the parent\n * @property {Ref<Object>} [$externalResults] - External error messages, like from server validation.\n */\n\n/**\n * Composition API compatible Vuelidate\n * Use inside the `setup` lifecycle hook\n * @param {Object | GlobalConfig} [validations] - Validations Object or the globalConfig.\n * @param {Object} [state] - State object - required if `validations` is a validation object.\n * @param {GlobalConfig} [globalConfig] - Config Object\n * @return {UnwrapRef<*>}\n */\n\n\nfunction useVuelidate(validations, state) {\n  var globalConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // if we pass only one argument, its most probably the globalConfig.\n  // This use case is so parents can just collect results of child forms.\n  if (arguments.length === 1) {\n    globalConfig = validations;\n    validations = undefined;\n    state = undefined;\n  }\n\n  var _globalConfig = globalConfig,\n      $registerAs = _globalConfig.$registerAs,\n      _globalConfig$$scope = _globalConfig.$scope,\n      $scope = _globalConfig$$scope === void 0 ? CollectFlag.COLLECT_ALL : _globalConfig$$scope,\n      $stopPropagation = _globalConfig.$stopPropagation,\n      $externalResults = _globalConfig.$externalResults;\n  var instance = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"getCurrentInstance\"])();\n  var componentOptions = instance ? vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isVue3\"] ? instance.type : instance.proxy.$options : {}; // if there is no registration name, add one.\n\n  if (!$registerAs && instance) {\n    // NOTE:\n    // ._uid // Vue 2.x Composition-API plugin\n    // .uid // Vue 3.0\n    var uid = instance.uid || instance._uid;\n    $registerAs = \"_vuelidate_\".concat(uid);\n  }\n\n  var validationResults = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])({});\n  var resultsCache = new ResultsStorage();\n\n  var _ref3 = instance ? nestedValidations({\n    $scope: $scope\n  }) : {\n    childResults: Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])({})\n  },\n      childResults = _ref3.childResults,\n      sendValidationResultsToParent = _ref3.sendValidationResultsToParent,\n      removeValidationResultsFromParent = _ref3.removeValidationResultsFromParent; // Options API\n\n\n  if (!validations && componentOptions.validations) {\n    var rules = componentOptions.validations;\n    state = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"ref\"])({});\n    Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"onBeforeMount\"])(function () {\n      // Delay binding state to validations defined with the Options API until mounting, when the data\n      // has been attached to the component instance. From that point on it will be reactive.\n      state.value = instance.proxy; // helper proxy for instance property access. It makes every reference\n      // reactive for the validation function\n\n      function ComputedProxyFactory(target) {\n        return new Proxy(target, {\n          get: function get(target, prop, receiver) {\n            return _typeof(target[prop]) === 'object' ? ComputedProxyFactory(target[prop]) : Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n              return target[prop];\n            });\n          }\n        });\n      }\n\n      Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(function () {\n        return isFunction(rules) ? rules.call(state.value, new ComputedProxyFactory(state.value)) : rules;\n      }, function (validations) {\n        validationResults.value = setValidations({\n          validations: validations,\n          state: state,\n          childResults: childResults,\n          resultsCache: resultsCache,\n          globalConfig: globalConfig,\n          instance: instance.proxy,\n          externalResults: instance.proxy.vuelidateExternalResults\n        });\n      }, {\n        immediate: true\n      });\n    });\n    globalConfig = componentOptions.validationsConfig || {};\n  } else {\n    var validationsWatchTarget = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"isRef\"])(validations) || isProxy(validations) ? validations // wrap plain objects in a reactive, so we can track changes if they have computed in them.\n    : Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"reactive\"])(validations || {});\n    Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(validationsWatchTarget, function (newValidationRules) {\n      validationResults.value = setValidations({\n        validations: newValidationRules,\n        state: state,\n        childResults: childResults,\n        resultsCache: resultsCache,\n        globalConfig: globalConfig,\n        instance: instance ? instance.proxy : {},\n        externalResults: $externalResults\n      });\n    }, {\n      immediate: true\n    });\n  }\n\n  if (instance) {\n    // send all the data to the parent when the function is invoked inside setup.\n    sendValidationResultsToParent(validationResults, {\n      $registerAs: $registerAs,\n      $scope: $scope,\n      $stopPropagation: $stopPropagation\n    }); // before this component is destroyed, remove all the data from the parent.\n\n    Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"onBeforeUnmount\"])(function () {\n      return removeValidationResultsFromParent($registerAs);\n    });\n  } // TODO: Change into reactive + watch\n\n\n  return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"computed\"])(function () {\n    return Object.assign({}, Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(validationResults.value), childResults.value);\n  });\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (useVuelidate);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZWxpZGF0ZS9jb3JlL2Rpc3QvaW5kZXguZXNtLmpzPzI1YTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUw7O0FBRXZMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUzs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNEQUFLO0FBQ2hCO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkRBQVUsV0FBVywyREFBVTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDJDQUEyQztBQUN4RDs7QUFFQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDOztBQUVBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLDJDQUEyQztBQUN6RCxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLHFCQUFxQjtBQUNuQyxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXLG1CQUFtQjtBQUMzQzs7QUFFQTtBQUNB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O0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Rix5REFBUTtBQUNyRztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDs7QUFFQSxNQUFNLHNEQUFLO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILGlDQUFpQyxzREFBSztBQUN0QyxNQUFNLHlEQUFRLGtCQUFrQjtBQUNoQyxJQUFJLHNEQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsSUFBSSxnRUFBZTtBQUNuQjtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSCxTQUFTLHlEQUFRO0FBQ2pCLDJCQUEyQixFQUFFLHNEQUFLO0FBQ2xDLEdBQUc7QUFDSDs7QUFFZSwyRUFBWSxFQUFDO0FBQ1MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZWxpZGF0ZS9jb3JlL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNSZWFjdGl2ZSwgaXNSZWFkb25seSwgdW5yZWYsIHJlYWN0aXZlLCBjb21wdXRlZCwgaXNSZWYsIHdhdGNoLCByZWYsIG5leHRUaWNrLCBnZXRDdXJyZW50SW5zdGFuY2UsIGlzVnVlMywgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBpbmplY3QsIHByb3ZpZGUgfSBmcm9tICd2dWUtZGVtaSc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBPYmoob2JqKSB7XG4gIHZhciBpZ25vcmVLZXlzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKGZ1bmN0aW9uIChvLCBrKSB7XG4gICAgaWYgKGlnbm9yZUtleXMuaW5jbHVkZXMoaykpIHJldHVybiBvO1xuICAgIG9ba10gPSB1bnJlZihvYmpba10pO1xuICAgIHJldHVybiBvO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpIHx8IGlzUmVhZG9ubHkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBfY2FsbChib2R5LCB0aGVuLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHJldHVybiB0aGVuID8gdGhlbihib2R5KCkpIDogYm9keSgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKGJvZHkoKSk7XG4gICAgcmV0dXJuIHRoZW4gPyByZXN1bHQudGhlbih0aGVuKSA6IHJlc3VsdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxufVxuXG52YXIgUk9PVF9QQVRIID0gJ19fcm9vdCc7XG4vKipcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJ3Z1ZS1kZW1pJykuQ29tcG9uZW50UHVibGljSW5zdGFuY2V9IFZ1ZUluc3RhbmNlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCd2dWUtZGVtaScpLkNvbXB1dGVkUmVmfSBDb21wdXRlZFJlZlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgndnVlLWRlbWknKS5XYXRjaFN0b3BIYW5kbGV9IFdhdGNoU3RvcEhhbmRsZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgTm9ybWFsaXplZFZhbGlkYXRvclxuICogQHByb3BlcnR5IHtWYWxpZGF0b3J9ICR2YWxpZGF0b3JcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nIHwgUmVmPFN0cmluZz4gfCBmdW5jdGlvbigqKTogc3RyaW5nfSBbJG1lc3NhZ2VdXG4gKiBAcHJvcGVydHkge09iamVjdCB8IFJlZjxPYmplY3Q+fSBbJHBhcmFtc11cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0IHwgUmVmPE9iamVjdD59IFskYXN5bmNdXG4gKiBAcHJvcGVydHkge1JlZjwqPltdfSBbJHdhdGNoVGFyZ2V0c11cbiAqL1xuXG4vKipcbiAqIFJlc3BvbnNlIGZvcm0gYSByYXcgVmFsaWRhdG9yIGZ1bmN0aW9uLlxuICogU2hvdWxkIHJldHVybiBhIEJvb2xlYW4gb3IgYW4gb2JqZWN0IHdpdGggJGludmFsaWQgcHJvcGVydHkuXG4gKiBAdHlwZWRlZiB7Qm9vbGVhbiB8IHsgJHZhbGlkOiBCb29sZWFuIH19IFZhbGlkYXRvclJlc3BvbnNlXG4gKi9cblxuLyoqXG4gKiBSYXcgdmFsaWRhdG9yIGZ1bmN0aW9uLCBiZWZvcmUgYmVpbmcgbm9ybWFsaXplZFxuICogQ2FuIHJldHVybiBhIFByb21pc2Ugb3IgYSB7QHNlZSBWYWxpZGF0b3JSZXNwb25zZX1cbiAqIEB0eXBlZGVmIHtmdW5jdGlvbigqKTogKChQcm9taXNlPFZhbGlkYXRvclJlc3BvbnNlPiB8IFZhbGlkYXRvclJlc3BvbnNlKSl9IFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogU29ydHMgdGhlIHZhbGlkYXRvcnMgZm9yIGEgc3RhdGUgdHJlZSBicmFuY2hcbiAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb24+fSB2YWxpZGF0aW9uc1Jhd1xuICogQHJldHVybiB7eyBydWxlczogT2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+LCBuZXN0ZWRWYWxpZGF0b3JzOiBPYmplY3QsIGNvbmZpZzogR2xvYmFsQ29uZmlnIH19XG4gKi9cblxuZnVuY3Rpb24gX2FzeW5jKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhcmdzID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYuYXBwbHkodGhpcywgYXJncykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gIH07XG59XG4vKipcbiAqIENhbGxzIGEgdmFsaWRhdGlvbiBydWxlIGJ5IHVud3JhcHBpbmcgaXRzIHZhbHVlIGZpcnN0IGZyb20gYSByZWYuXG4gKiBAcGFyYW0ge1ZhbGlkYXRvcn0gcnVsZVxuICogQHBhcmFtIHtSZWZ9IHZhbHVlXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZVxuICogQHJldHVybiB7UHJvbWlzZTxWYWxpZGF0b3JSZXNwb25zZT4gfCBWYWxpZGF0b3JSZXNwb25zZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNvcnRWYWxpZGF0aW9ucygpIHtcbiAgdmFyIHZhbGlkYXRpb25zUmF3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIHZhbGlkYXRpb25zID0gdW5yZWYodmFsaWRhdGlvbnNSYXcpO1xuICB2YXIgdmFsaWRhdGlvbktleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9ucyk7XG4gIHZhciBydWxlcyA9IHt9O1xuICB2YXIgbmVzdGVkVmFsaWRhdG9ycyA9IHt9O1xuICB2YXIgY29uZmlnID0ge307XG4gIHZhbGlkYXRpb25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB2ID0gdmFsaWRhdGlvbnNba2V5XTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBub3JtYWxpemVkLCB1c2UgaXRcbiAgICAgIGNhc2UgaXNGdW5jdGlvbih2LiR2YWxpZGF0b3IpOlxuICAgICAgICBydWxlc1trZXldID0gdjtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBJZiBpdCBpcyBqdXN0IGEgZnVuY3Rpb24sIG5vcm1hbGl6ZSBpdCBmaXJzdFxuICAgICAgLy8gaW50byB7ICR2YWxpZGF0b3I6IDxGdW4+IH1cblxuICAgICAgY2FzZSBpc0Z1bmN0aW9uKHYpOlxuICAgICAgICBydWxlc1trZXldID0ge1xuICAgICAgICAgICR2YWxpZGF0b3I6IHZcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBDYXRjaCAkLXByZWZpeGVkIHByb3BlcnRpZXMgYXMgY29uZmlnXG5cbiAgICAgIGNhc2Uga2V5LnN0YXJ0c1dpdGgoJyQnKTpcbiAgICAgICAgY29uZmlnW2tleV0gPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIElmIGl0IGRvZXNu4oCZdCBtYXRjaCBhbnkgb2YgdGhlIGFib3ZlLFxuICAgICAgLy8gdHJlYXQgYXMgbmVzdGVkVmFsaWRhdG9ycyBzdGF0ZSBwcm9wZXJ0eVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXN0ZWRWYWxpZGF0b3JzW2tleV0gPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcnVsZXM6IHJ1bGVzLFxuICAgIG5lc3RlZFZhbGlkYXRvcnM6IG5lc3RlZFZhbGlkYXRvcnMsXG4gICAgY29uZmlnOiBjb25maWdcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbFJ1bGUocnVsZSwgdmFsdWUsIGluc3RhbmNlKSB7XG4gIHZhciB2ID0gdW5yZWYodmFsdWUpO1xuICByZXR1cm4gcnVsZS5jYWxsKGluc3RhbmNlLCB2LCBpbnN0YW5jZSk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIHZhbGlkYXRvciByZXN1bHRcbiAqIEFsbG93cyBwYXNzaW5nIGEgYm9vbGVhbiBvZiBhbiBvYmplY3QgbGlrZSBgeyAkdmFsaWQ6IEJvb2xlYW4gfWBcbiAqIEBwYXJhbSB7VmFsaWRhdG9yUmVzcG9uc2V9IHJlc3VsdCAtIFZhbGlkYXRvciByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3JSZXNwb25zZShyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC4kdmFsaWQgIT09IHVuZGVmaW5lZCA/ICFyZXN1bHQuJHZhbGlkIDogIXJlc3VsdDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFuIGFzeW5jIHZhbGlkYXRvci5cbiAqIEBwYXJhbSB7VmFsaWRhdG9yfSBydWxlXG4gKiBAcGFyYW0ge1JlZjwqPn0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmPEJvb2xlYW4+fSAkcGVuZGluZ1xuICogQHBhcmFtIHtSZWY8Qm9vbGVhbj59ICRkaXJ0eVxuICogQHBhcmFtIHtHbG9iYWxDb25maWd9IGNvbmZpZ1xuICogQHBhcmFtIHtib29sZWFufSBjb25maWcuJGxhenlcbiAqIEBwYXJhbSB7UmVmPCo+fSAkcmVzcG9uc2VcbiAqIEBwYXJhbSB7VnVlSW5zdGFuY2V9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1JlZjwqPltdfSB3YXRjaFRhcmdldHNcbiAqIEByZXR1cm4ge3sgJGludmFsaWQ6IFJlZjxCb29sZWFuPiwgJHVud2F0Y2g6IFdhdGNoU3RvcEhhbmRsZSB9fVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNSZXN1bHQocnVsZSwgbW9kZWwsICRwZW5kaW5nLCAkZGlydHksIF9yZWYsICRyZXNwb25zZSwgaW5zdGFuY2UpIHtcbiAgdmFyICRsYXp5ID0gX3JlZi4kbGF6eTtcbiAgdmFyIHdhdGNoVGFyZ2V0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogW107XG4gIHZhciAkaW52YWxpZCA9IHJlZighISRkaXJ0eS52YWx1ZSk7XG4gIHZhciAkcGVuZGluZ0NvdW50ZXIgPSByZWYoMCk7XG4gICRwZW5kaW5nLnZhbHVlID0gZmFsc2U7XG4gIHZhciAkdW53YXRjaCA9IHdhdGNoKFttb2RlbCwgJGRpcnR5XS5jb25jYXQod2F0Y2hUYXJnZXRzKSwgZnVuY3Rpb24gKCkge1xuICAgIGlmICgkbGF6eSAmJiAhJGRpcnR5LnZhbHVlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJ1bGVSZXN1bHQ7IC8vIG1ha2Ugc3VyZSB3ZSBkb250IGJyZWFrIGlmIGEgdmFsaWRhdG9yIHRocm93c1xuXG4gICAgdHJ5IHtcbiAgICAgIHJ1bGVSZXN1bHQgPSBjYWxsUnVsZShydWxlLCBtb2RlbCwgaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gY29udmVydCB0byBhIHByb21pc2UsIHNvIHdlIGNhbiBoYW5kbGUgaXQgYXN5bmNcbiAgICAgIHJ1bGVSZXN1bHQgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgICRwZW5kaW5nQ291bnRlci52YWx1ZSsrO1xuICAgICRwZW5kaW5nLnZhbHVlID0gISEkcGVuZGluZ0NvdW50ZXIudmFsdWU7XG4gICAgJGludmFsaWQudmFsdWUgPSB0cnVlO1xuICAgIFByb21pc2UucmVzb2x2ZShydWxlUmVzdWx0KS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAkcGVuZGluZ0NvdW50ZXIudmFsdWUtLTtcbiAgICAgICRwZW5kaW5nLnZhbHVlID0gISEkcGVuZGluZ0NvdW50ZXIudmFsdWU7XG4gICAgICAkcmVzcG9uc2UudmFsdWUgPSBkYXRhO1xuICAgICAgJGludmFsaWQudmFsdWUgPSBub3JtYWxpemVWYWxpZGF0b3JSZXNwb25zZShkYXRhKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgJHBlbmRpbmdDb3VudGVyLnZhbHVlLS07XG4gICAgICAkcGVuZGluZy52YWx1ZSA9ICEhJHBlbmRpbmdDb3VudGVyLnZhbHVlO1xuICAgICAgJHJlc3BvbnNlLnZhbHVlID0gZXJyb3I7XG4gICAgICAkaW52YWxpZC52YWx1ZSA9IHRydWU7XG4gICAgfSk7XG4gIH0sIHtcbiAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgZGVlcDogX3R5cGVvZihtb2RlbCkgPT09ICdvYmplY3QnXG4gIH0pO1xuICByZXR1cm4ge1xuICAgICRpbnZhbGlkOiAkaW52YWxpZCxcbiAgICAkdW53YXRjaDogJHVud2F0Y2hcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgc3luYyB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7VmFsaWRhdG9yfSBydWxlXG4gKiBAcGFyYW0ge1JlZjwqPn0gbW9kZWxcbiAqIEBwYXJhbSB7UmVmPEJvb2xlYW4+fSAkZGlydHlcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBjb25maWdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLiRsYXp5XG4gKiBAcGFyYW0ge1JlZjwqPn0gJHJlc3BvbnNlXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZVxuICogQHJldHVybiB7eyR1bndhdGNoOiAoZnVuY3Rpb24oKToge30pLCAkaW52YWxpZDogQ29tcHV0ZWRSZWY8Ym9vbGVhbj59fVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU3luY1Jlc3VsdChydWxlLCBtb2RlbCwgJGRpcnR5LCBfcmVmMiwgJHJlc3BvbnNlLCBpbnN0YW5jZSkge1xuICB2YXIgJGxhenkgPSBfcmVmMi4kbGF6eTtcblxuICB2YXIgJHVud2F0Y2ggPSBmdW5jdGlvbiAkdW53YXRjaCgpIHtcbiAgICByZXR1cm4ge307XG4gIH07XG5cbiAgdmFyICRpbnZhbGlkID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgkbGF6eSAmJiAhJGRpcnR5LnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNhbGxSdWxlKHJ1bGUsIG1vZGVsLCBpbnN0YW5jZSk7XG4gICAgICAkcmVzcG9uc2UudmFsdWUgPSByZXN1bHQ7XG4gICAgICByZXR1cm4gbm9ybWFsaXplVmFsaWRhdG9yUmVzcG9uc2UocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICRyZXNwb25zZS52YWx1ZSA9IGVycjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgJHVud2F0Y2g6ICR1bndhdGNoLFxuICAgICRpbnZhbGlkOiAkaW52YWxpZFxuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWxpZGF0aW9uIHJlc3VsdC5cbiAqIERldGVjdHMgYXN5bmMgYW5kIHN5bmMgdmFsaWRhdG9ycy5cbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFZhbGlkYXRvcn0gcnVsZVxuICogQHBhcmFtIHtSZWY8Kj59IG1vZGVsXG4gKiBAcGFyYW0ge1JlZjxib29sZWFuPn0gJGRpcnR5XG4gKiBAcGFyYW0ge0dsb2JhbENvbmZpZ30gY29uZmlnIC0gVnVlbGlkYXRlIGNvbmZpZ1xuICogQHBhcmFtIHtWdWVJbnN0YW5jZX0gaW5zdGFuY2UgLSBjb21wb25lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JOYW1lIC0gbmFtZSBvZiB0aGUgY3VycmVudCB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eUtleSAtIHRoZSBjdXJyZW50IHByb3BlcnR5IHdlIGFyZSB2YWxpZGF0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlQYXRoIC0gdGhlIGRlZXAgcGF0aCB0byB0aGUgdmFsaWRhdGVkIHByb3BlcnR5XG4gKiBAcmV0dXJuIHt7ICRwYXJhbXM6ICosICRtZXNzYWdlOiBSZWY8U3RyaW5nPiwgJHBlbmRpbmc6IFJlZjxCb29sZWFuPiwgJGludmFsaWQ6IFJlZjxCb29sZWFuPiwgJHJlc3BvbnNlOiBSZWY8Kj4sICR1bndhdGNoOiBXYXRjaFN0b3BIYW5kbGUgfX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvclJlc3VsdChydWxlLCBtb2RlbCwgJGRpcnR5LCBjb25maWcsIGluc3RhbmNlLCB2YWxpZGF0b3JOYW1lLCBwcm9wZXJ0eUtleSwgcHJvcGVydHlQYXRoKSB7XG4gIHZhciAkcGVuZGluZyA9IHJlZihmYWxzZSk7XG4gIHZhciAkcGFyYW1zID0gcnVsZS4kcGFyYW1zIHx8IHt9O1xuICB2YXIgJHJlc3BvbnNlID0gcmVmKG51bGwpO1xuICB2YXIgJGludmFsaWQ7XG4gIHZhciAkdW53YXRjaDtcblxuICBpZiAocnVsZS4kYXN5bmMpIHtcbiAgICB2YXIgX2NyZWF0ZUFzeW5jUmVzdWx0ID0gY3JlYXRlQXN5bmNSZXN1bHQocnVsZS4kdmFsaWRhdG9yLCBtb2RlbCwgJHBlbmRpbmcsICRkaXJ0eSwgY29uZmlnLCAkcmVzcG9uc2UsIGluc3RhbmNlLCBydWxlLiR3YXRjaFRhcmdldHMpO1xuXG4gICAgJGludmFsaWQgPSBfY3JlYXRlQXN5bmNSZXN1bHQuJGludmFsaWQ7XG4gICAgJHVud2F0Y2ggPSBfY3JlYXRlQXN5bmNSZXN1bHQuJHVud2F0Y2g7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jcmVhdGVTeW5jUmVzdWx0ID0gY3JlYXRlU3luY1Jlc3VsdChydWxlLiR2YWxpZGF0b3IsIG1vZGVsLCAkZGlydHksIGNvbmZpZywgJHJlc3BvbnNlLCBpbnN0YW5jZSk7XG5cbiAgICAkaW52YWxpZCA9IF9jcmVhdGVTeW5jUmVzdWx0LiRpbnZhbGlkO1xuICAgICR1bndhdGNoID0gX2NyZWF0ZVN5bmNSZXN1bHQuJHVud2F0Y2g7XG4gIH1cblxuICB2YXIgbWVzc2FnZSA9IHJ1bGUuJG1lc3NhZ2U7XG4gIHZhciAkbWVzc2FnZSA9IGlzRnVuY3Rpb24obWVzc2FnZSkgPyBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UodW53cmFwT2JqKHtcbiAgICAgICRwZW5kaW5nOiAkcGVuZGluZyxcbiAgICAgICRpbnZhbGlkOiAkaW52YWxpZCxcbiAgICAgICRwYXJhbXM6IHVud3JhcE9iaigkcGFyYW1zKSxcbiAgICAgIC8vICRwYXJhbXMgY2FuIGhvbGQgcmVmcywgc28gd2UgdW53cmFwIHRoZW0gZm9yIGVhc3kgYWNjZXNzXG4gICAgICAkbW9kZWw6IG1vZGVsLFxuICAgICAgJHJlc3BvbnNlOiAkcmVzcG9uc2UsXG4gICAgICAkdmFsaWRhdG9yOiB2YWxpZGF0b3JOYW1lLFxuICAgICAgJHByb3BlcnR5UGF0aDogcHJvcGVydHlQYXRoLFxuICAgICAgJHByb3BlcnR5OiBwcm9wZXJ0eUtleVxuICAgIH0pKTtcbiAgfSkgOiBtZXNzYWdlIHx8ICcnO1xuICByZXR1cm4ge1xuICAgICRtZXNzYWdlOiAkbWVzc2FnZSxcbiAgICAkcGFyYW1zOiAkcGFyYW1zLFxuICAgICRwZW5kaW5nOiAkcGVuZGluZyxcbiAgICAkaW52YWxpZDogJGludmFsaWQsXG4gICAgJHJlc3BvbnNlOiAkcmVzcG9uc2UsXG4gICAgJHVud2F0Y2g6ICR1bndhdGNoXG4gIH07XG59XG4vKipcbiAqIEB0eXBlZGVmIEVycm9yT2JqZWN0XG4gKiBAcHJvcGVydHkge1JlZjxTdHJpbmc+fSAkbWVzc2FnZSAtIFJlYWN0aXZlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7UmVmPE9iamVjdD59ICRwYXJhbXMgLSBQYXJhbXMgcGFzc2VkIGZyb20gd2l0aFBhcmFtc1xuICogQHByb3BlcnR5IHtSZWY8Qm9vbGVhbj59ICRwZW5kaW5nIC0gSWYgdmFsaWRhdGlvbiBpcyBwZW5kaW5nXG4gKiBAcHJvcGVydHkge1N0cmluZ30gJHByb3BlcnR5IC0gU3RhdGUga2V5XG4gKiBAcHJvcGVydHkge1N0cmluZ30gJHByb3BlcnR5UGF0aCAtIERvdCBub3RhdGlvbiBwYXRoIHRvIHN0YXRlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gJHZhbGlkYXRvciAtIFZhbGlkYXRvciBuYW1lXG4gKiBAcHJvcGVydHkge1N0cmluZ30gJHVpZCAtIFVuaXF1ZSBpZGVudGlmaWVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBWYWxpZGF0aW9uUmVzdWx0XG4gKiBAcHJvcGVydHkge1JlZjxCb29sZWFuPn0gJHBlbmRpbmdcbiAqIEBwcm9wZXJ0eSB7UmVmPEJvb2xlYW4+fSAkZGlydHlcbiAqIEBwcm9wZXJ0eSB7UmVmPEJvb2xlYW4+fSAkaW52YWxpZFxuICogQHByb3BlcnR5IHtSZWY8Qm9vbGVhbj59ICRlcnJvclxuICogQHByb3BlcnR5IHtSZWY8U3RyaW5nPn0gJHBhdGhcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICR0b3VjaFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gJHJlc2V0XG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEVycm9yT2JqZWN0W10+fSAkZXJyb3JzXG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEVycm9yT2JqZWN0W10+fSAkc2lsZW50RXJyb3JzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBtYWluIFZhbGlkYXRpb24gUmVzdWx0cyBvYmplY3QgZm9yIGEgc3RhdGUgdHJlZVxuICogV2Fsa3MgdGhlIHRyZWUncyB0b3AgbGV2ZWwgYnJhbmNoZXNcbiAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+fSBydWxlcyAtIFJ1bGVzIGZvciB0aGUgY3VycmVudCBzdGF0ZSB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgLSBDdXJyZW50IHN0YXRlIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gS2V5IGZvciB0aGUgY3VycmVudCBzdGF0ZSB0cmVlXG4gKiBAcGFyYW0ge1Jlc3VsdHNTdG9yYWdlfSBbcmVzdWx0c0NhY2hlXSAtIEEgY2FjaGUgbWFwIG9mIGFsbCB0aGUgdmFsaWRhdG9yc1xuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXSAtIHRoZSBjdXJyZW50IHByb3BlcnR5IHBhdGhcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBbY29uZmlnXSAtIHRoZSBjb25maWcgb2JqZWN0XG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBpbnN0YW5jZVxuICogQHBhcmFtIHtDb21wdXRlZFJlZjxPYmplY3Q+fSBleHRlcm5hbFJlc3VsdHNcbiAqIEByZXR1cm4ge1ZhbGlkYXRpb25SZXN1bHQgfCB7fX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb25SZXN1bHRzKHJ1bGVzLCBtb2RlbCwga2V5LCByZXN1bHRzQ2FjaGUsIHBhdGgsIGNvbmZpZywgaW5zdGFuY2UsIGV4dGVybmFsUmVzdWx0cykge1xuICAvLyBjb2xsZWN0IHRoZSBwcm9wZXJ0eSBrZXlzXG4gIHZhciBydWxlS2V5cyA9IE9iamVjdC5rZXlzKHJ1bGVzKTtcbiAgdmFyIGNhY2hlZFJlc3VsdCA9IHJlc3VsdHNDYWNoZS5nZXQocGF0aCwgcnVsZXMpO1xuICB2YXIgJGRpcnR5ID0gcmVmKGZhbHNlKTtcblxuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgLy8gaWYgdGhlIHJ1bGVzIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUsIHVzZSB0aGUgY2FjaGVkIHJlc3VsdHNcbiAgICBpZiAoIWNhY2hlZFJlc3VsdC4kcGFydGlhbCkgcmV0dXJuIGNhY2hlZFJlc3VsdDsgLy8gcmVtb3ZlIG9sZCB3YXRjaGVyc1xuXG4gICAgY2FjaGVkUmVzdWx0LiR1bndhdGNoKCk7IC8vIHVzZSB0aGUgYCRkaXJ0eS52YWx1ZWAsIHNvIHdlIGRvbnQgc2F2ZSByZWZlcmVuY2VzIGJ5IGFjY2lkZW50XG5cbiAgICAkZGlydHkudmFsdWUgPSBjYWNoZWRSZXN1bHQuJGRpcnR5LnZhbHVlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAvLyByZXN0b3JlICRkaXJ0eSBmcm9tIGNhY2hlXG4gICAgJGRpcnR5OiAkZGlydHksXG4gICAgJHBhdGg6IHBhdGgsXG4gICAgJHRvdWNoOiBmdW5jdGlvbiAkdG91Y2goKSB7XG4gICAgICBpZiAoISRkaXJ0eS52YWx1ZSkgJGRpcnR5LnZhbHVlID0gdHJ1ZTtcbiAgICB9LFxuICAgICRyZXNldDogZnVuY3Rpb24gJHJlc2V0KCkge1xuICAgICAgaWYgKCRkaXJ0eS52YWx1ZSkgJGRpcnR5LnZhbHVlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogSWYgdGhlcmUgYXJlIG5vIHZhbGlkYXRpb24gcnVsZXMsIGl0IGlzIG1vc3QgbGlrZWx5XG4gICAqIGEgdG9wIGxldmVsIHN0YXRlLCBha2Egcm9vdFxuICAgKi9cblxuICBpZiAoIXJ1bGVLZXlzLmxlbmd0aCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBjYWNoZWQgcmVzdWx0cywgd2Ugc2hvdWxkIG92ZXJ3cml0ZSB0aGVtIHdpdGggdGhlIG5ldyBvbmVzXG4gICAgY2FjaGVkUmVzdWx0ICYmIHJlc3VsdHNDYWNoZS5zZXQocGF0aCwgcnVsZXMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJ1bGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKHJ1bGVLZXkpIHtcbiAgICByZXN1bHRbcnVsZUtleV0gPSBjcmVhdGVWYWxpZGF0b3JSZXN1bHQocnVsZXNbcnVsZUtleV0sIG1vZGVsLCByZXN1bHQuJGRpcnR5LCBjb25maWcsIGluc3RhbmNlLCBydWxlS2V5LCBrZXksIHBhdGgpO1xuICB9KTtcbiAgcmVzdWx0LiRleHRlcm5hbFJlc3VsdHMgPSBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFleHRlcm5hbFJlc3VsdHMudmFsdWUpIHJldHVybiBbXTtcbiAgICByZXR1cm4gW10uY29uY2F0KGV4dGVybmFsUmVzdWx0cy52YWx1ZSkubWFwKGZ1bmN0aW9uIChzdHJpbmdFcnJvciwgaW5kZXgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRwcm9wZXJ0eVBhdGg6IHBhdGgsXG4gICAgICAgICRwcm9wZXJ0eToga2V5LFxuICAgICAgICAkdmFsaWRhdG9yOiAnJGV4dGVybmFsUmVzdWx0cycsXG4gICAgICAgICR1aWQ6IFwiXCIuY29uY2F0KHBhdGgsIFwiLVwiKS5jb25jYXQoaW5kZXgpLFxuICAgICAgICAkbWVzc2FnZTogc3RyaW5nRXJyb3IsXG4gICAgICAgICRwYXJhbXM6IHt9LFxuICAgICAgICAkcmVzcG9uc2U6IG51bGwsXG4gICAgICAgICRwZW5kaW5nOiBmYWxzZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG4gIHJlc3VsdC4kaW52YWxpZCA9IGNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISFyZXN1bHQuJGV4dGVybmFsUmVzdWx0cy52YWx1ZS5sZW5ndGggfHwgcnVsZUtleXMuc29tZShmdW5jdGlvbiAocnVsZUtleSkge1xuICAgICAgcmV0dXJuIHVucmVmKHJlc3VsdFtydWxlS2V5XS4kaW52YWxpZCk7XG4gICAgfSk7XG4gIH0pO1xuICByZXN1bHQuJHBlbmRpbmcgPSBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJ1bGVLZXlzLnNvbWUoZnVuY3Rpb24gKHJ1bGVLZXkpIHtcbiAgICAgIHJldHVybiB1bnJlZihyZXN1bHRbcnVsZUtleV0uJHBlbmRpbmcpO1xuICAgIH0pO1xuICB9KTtcbiAgcmVzdWx0LiRlcnJvciA9IGNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmVzdWx0LiRpbnZhbGlkLnZhbHVlICYmIHJlc3VsdC4kZGlydHkudmFsdWU7XG4gIH0pO1xuICByZXN1bHQuJHNpbGVudEVycm9ycyA9IGNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcnVsZUtleXMuZmlsdGVyKGZ1bmN0aW9uIChydWxlS2V5KSB7XG4gICAgICByZXR1cm4gdW5yZWYocmVzdWx0W3J1bGVLZXldLiRpbnZhbGlkKTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKHJ1bGVLZXkpIHtcbiAgICAgIHZhciByZXMgPSByZXN1bHRbcnVsZUtleV07XG4gICAgICByZXR1cm4gcmVhY3RpdmUoe1xuICAgICAgICAkcHJvcGVydHlQYXRoOiBwYXRoLFxuICAgICAgICAkcHJvcGVydHk6IGtleSxcbiAgICAgICAgJHZhbGlkYXRvcjogcnVsZUtleSxcbiAgICAgICAgJHVpZDogXCJcIi5jb25jYXQocGF0aCwgXCItXCIpLmNvbmNhdChydWxlS2V5KSxcbiAgICAgICAgJG1lc3NhZ2U6IHJlcy4kbWVzc2FnZSxcbiAgICAgICAgJHBhcmFtczogcmVzLiRwYXJhbXMsXG4gICAgICAgICRyZXNwb25zZTogcmVzLiRyZXNwb25zZSxcbiAgICAgICAgJHBlbmRpbmc6IHJlcy4kcGVuZGluZ1xuICAgICAgfSk7XG4gICAgfSkuY29uY2F0KHJlc3VsdC4kZXh0ZXJuYWxSZXN1bHRzLnZhbHVlKTtcbiAgfSk7XG4gIHJlc3VsdC4kZXJyb3JzID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN1bHQuJGRpcnR5LnZhbHVlID8gcmVzdWx0LiRzaWxlbnRFcnJvcnMudmFsdWUgOiBbXTtcbiAgfSk7XG5cbiAgcmVzdWx0LiR1bndhdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBydWxlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlS2V5KSB7XG4gICAgICByZXN1bHRbcnVsZUtleV0uJHVud2F0Y2goKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXN1bHRzQ2FjaGUuc2V0KHBhdGgsIHJ1bGVzLCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb2xsZWN0cyB0aGUgdmFsaWRhdGlvbiByZXN1bHRzIG9mIGFsbCBuZXN0ZWQgc3RhdGUgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3Q8Tm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbj59IHZhbGlkYXRpb25zIC0gVGhlIHZhbGlkYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBuZXN0ZWRTdGF0ZSAtIEN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gUGF0aCB0byBjdXJyZW50IHByb3BlcnR5XG4gKiBAcGFyYW0ge1Jlc3VsdHNTdG9yYWdlfSByZXN1bHRzQ2FjaGUgLSBWYWxpZGF0aW9ucyBjYWNoZSBtYXBcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBjb25maWcgLSBUaGUgY29uZmlnIG9iamVjdFxuICogQHBhcmFtIHtWdWVJbnN0YW5jZX0gaW5zdGFuY2UgLSBUaGUgY3VycmVudCBWdWUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Q29tcHV0ZWRSZWY8b2JqZWN0Pn0gbmVzdGVkRXh0ZXJuYWxSZXN1bHRzIC0gVGhlIGV4dGVybmFsIHJlc3VsdHMgZm9yIHRoaXMgbmVzdGVkIGNvbGxlY3Rpb25cbiAqIEByZXR1cm4ge3t9fVxuICovXG5cblxuZnVuY3Rpb24gY29sbGVjdE5lc3RlZFZhbGlkYXRpb25SZXN1bHRzKHZhbGlkYXRpb25zLCBuZXN0ZWRTdGF0ZSwgcGF0aCwgcmVzdWx0c0NhY2hlLCBjb25maWcsIGluc3RhbmNlLCBuZXN0ZWRFeHRlcm5hbFJlc3VsdHMpIHtcbiAgdmFyIG5lc3RlZFZhbGlkYXRpb25LZXlzID0gT2JqZWN0LmtleXModmFsaWRhdGlvbnMpOyAvLyBpZiB3ZSBoYXZlIG5vIHN0YXRlLCByZXR1cm4gZW1wdHkgb2JqZWN0XG5cbiAgaWYgKCFuZXN0ZWRWYWxpZGF0aW9uS2V5cy5sZW5ndGgpIHJldHVybiB7fTtcbiAgcmV0dXJuIG5lc3RlZFZhbGlkYXRpb25LZXlzLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywgbmVzdGVkS2V5KSB7XG4gICAgLy8gYnVpbGQgdmFsaWRhdGlvbiByZXN1bHRzIGZvciBuZXN0ZWQgc3RhdGVcbiAgICByZXN1bHRzW25lc3RlZEtleV0gPSBzZXRWYWxpZGF0aW9ucyh7XG4gICAgICB2YWxpZGF0aW9uczogdmFsaWRhdGlvbnNbbmVzdGVkS2V5XSxcbiAgICAgIHN0YXRlOiBuZXN0ZWRTdGF0ZSxcbiAgICAgIGtleTogbmVzdGVkS2V5LFxuICAgICAgcGFyZW50S2V5OiBwYXRoLFxuICAgICAgcmVzdWx0c0NhY2hlOiByZXN1bHRzQ2FjaGUsXG4gICAgICBnbG9iYWxDb25maWc6IGNvbmZpZyxcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgIGV4dGVybmFsUmVzdWx0czogbmVzdGVkRXh0ZXJuYWxSZXN1bHRzXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sIHt9KTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBNZXRhIGZpZWxkcyBmcm9tIHRoZSByZXN1bHRzXG4gKiBAcGFyYW0ge1ZhbGlkYXRpb25SZXN1bHR8e319IHJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFZhbGlkYXRpb25SZXN1bHQ+W119IG5lc3RlZFJlc3VsdHNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIFZhbGlkYXRpb25SZXN1bHQ+W119IGNoaWxkUmVzdWx0c1xuICogQHJldHVybiB7eyRhbnlEaXJ0eTogUmVmPEJvb2xlYW4+LCAkZXJyb3I6IFJlZjxCb29sZWFuPiwgJGludmFsaWQ6IFJlZjxCb29sZWFuPiwgJGVycm9yczogUmVmPEVycm9yT2JqZWN0W10+LCAkZGlydHk6IFJlZjxCb29sZWFuPiwgJHRvdWNoOiBGdW5jdGlvbiwgJHJlc2V0OiBGdW5jdGlvbiB9fVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWV0YUZpZWxkcyhyZXN1bHRzLCBuZXN0ZWRSZXN1bHRzLCBjaGlsZFJlc3VsdHMpIHtcbiAgdmFyIGFsbFJlc3VsdHMgPSBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFtuZXN0ZWRSZXN1bHRzLCBjaGlsZFJlc3VsdHNdLmZpbHRlcihmdW5jdGlvbiAocmVzKSB7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWxsUmVzLCByZXMpIHtcbiAgICAgIHJldHVybiBhbGxSZXMuY29uY2F0KE9iamVjdC52YWx1ZXModW5yZWYocmVzKSkpO1xuICAgIH0sIFtdKTtcbiAgfSk7IC8vIHJldHVybnMgYCRkaXJ0eWAgYXMgdHJ1ZSwgaWYgYWxsIGNoaWxkcmVuIGFyZSBkaXJ0eVxuXG4gIHZhciAkZGlydHkgPSBjb21wdXRlZCh7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cy4kZGlydHkudmFsdWUgfHwgKGFsbFJlc3VsdHMudmFsdWUubGVuZ3RoID8gYWxsUmVzdWx0cy52YWx1ZS5ldmVyeShmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gci4kZGlydHk7XG4gICAgICB9KSA6IGZhbHNlKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHYpIHtcbiAgICAgIHJlc3VsdHMuJGRpcnR5LnZhbHVlID0gdjtcbiAgICB9XG4gIH0pO1xuICB2YXIgJHNpbGVudEVycm9ycyA9IGNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjdXJyZW50IHN0YXRlIGxldmVsIGVycm9ycywgZmFsbGJhY2sgdG8gZW1wdHkgYXJyYXkgaWYgcm9vdFxuICAgIHZhciBtb2RlbEVycm9ycyA9IHVucmVmKHJlc3VsdHMuJHNpbGVudEVycm9ycykgfHwgW107IC8vIGNvbGxlY3QgYWxsIG5lc3RlZCBhbmQgY2hpbGQgJHNpbGVudEVycm9yc1xuXG4gICAgdmFyIG5lc3RlZEVycm9ycyA9IGFsbFJlc3VsdHMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiAodW5yZWYocmVzdWx0KS4kc2lsZW50RXJyb3JzIHx8IFtdKS5sZW5ndGg7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChlcnJvcnMsIHJlc3VsdCkge1xuICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQuYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0LiRzaWxlbnRFcnJvcnMpKTtcbiAgICB9LCBbXSk7IC8vIG1lcmdlIHRoZSAkc2lsZW50RXJyb3JzXG5cbiAgICByZXR1cm4gbW9kZWxFcnJvcnMuY29uY2F0KG5lc3RlZEVycm9ycyk7XG4gIH0pO1xuICB2YXIgJGVycm9ycyA9IGNvbXB1dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjdXJyZW50IHN0YXRlIGxldmVsIGVycm9ycywgZmFsbGJhY2sgdG8gZW1wdHkgYXJyYXkgaWYgcm9vdFxuICAgIHZhciBtb2RlbEVycm9ycyA9IHVucmVmKHJlc3VsdHMuJGVycm9ycykgfHwgW107IC8vIGNvbGxlY3QgYWxsIG5lc3RlZCBhbmQgY2hpbGQgJGVycm9yc1xuXG4gICAgdmFyIG5lc3RlZEVycm9ycyA9IGFsbFJlc3VsdHMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiAodW5yZWYocmVzdWx0KS4kZXJyb3JzIHx8IFtdKS5sZW5ndGg7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uIChlcnJvcnMsIHJlc3VsdCkge1xuICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQuYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0LiRlcnJvcnMpKTtcbiAgICB9LCBbXSk7IC8vIG1lcmdlIHRoZSAkZXJyb3JzXG5cbiAgICByZXR1cm4gbW9kZWxFcnJvcnMuY29uY2F0KG5lc3RlZEVycm9ycyk7XG4gIH0pO1xuICB2YXIgJGludmFsaWQgPSBjb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgvLyBpZiBhbnkgb2YgdGhlIG5lc3RlZCB2YWx1ZXMgaXMgaW52YWxpZFxuICAgICAgYWxsUmVzdWx0cy52YWx1ZS5zb21lKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLiRpbnZhbGlkO1xuICAgICAgfSkgfHwgLy8gb3IgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgaW52YWxpZFxuICAgICAgdW5yZWYocmVzdWx0cy4kaW52YWxpZCkgfHwgLy8gZmFsbGJhY2sgdG8gZmFsc2UgaWYgaXMgcm9vdFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9KTtcbiAgdmFyICRwZW5kaW5nID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoLy8gaWYgYW55IG9mIHRoZSBuZXN0ZWQgdmFsdWVzIGlzIHBlbmRpbmdcbiAgICAgIGFsbFJlc3VsdHMudmFsdWUuc29tZShmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gdW5yZWYoci4kcGVuZGluZyk7XG4gICAgICB9KSB8fCAvLyBpZiBhbnkgb2YgdGhlIGN1cnJlbnQgc3RhdGUgdmFsaWRhdG9ycyBpcyBwZW5kaW5nXG4gICAgICB1bnJlZihyZXN1bHRzLiRwZW5kaW5nKSB8fCAvLyBmYWxsYmFjayB0byBmYWxzZSBpZiBpcyByb290XG4gICAgICBmYWxzZVxuICAgICk7XG4gIH0pO1xuICB2YXIgJGFueURpcnR5ID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGxSZXN1bHRzLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByLiRkaXJ0eTtcbiAgICB9KSB8fCBhbGxSZXN1bHRzLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByLiRhbnlEaXJ0eTtcbiAgICB9KSB8fCAkZGlydHkudmFsdWU7XG4gIH0pO1xuICB2YXIgJGVycm9yID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkaW52YWxpZC52YWx1ZSAmJiAkZGlydHkudmFsdWUgfHwgZmFsc2U7XG4gIH0pO1xuXG4gIHZhciAkdG91Y2ggPSBmdW5jdGlvbiAkdG91Y2goKSB7XG4gICAgLy8gY2FsbCB0aGUgcm9vdCAkdG91Y2hcbiAgICByZXN1bHRzLiR0b3VjaCgpOyAvLyBjYWxsIGFsbCBuZXN0ZWQgbGV2ZWwgJHRvdWNoXG5cbiAgICBhbGxSZXN1bHRzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LiR0b3VjaCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciAkcmVzZXQgPSBmdW5jdGlvbiAkcmVzZXQoKSB7XG4gICAgLy8gcmVzZXQgdGhlIHJvb3QgJGRpcnR5IHN0YXRlXG4gICAgcmVzdWx0cy4kcmVzZXQoKTsgLy8gcmVzZXQgYWxsIHRoZSBjaGlsZHJlbiAkZGlydHkgc3RhdGVzXG5cbiAgICBhbGxSZXN1bHRzLnZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmVzdWx0LiRyZXNldCgpO1xuICAgIH0pO1xuICB9OyAvLyBFbnN1cmUgdGhhdCBpZiBhbGwgY2hpbGQgYW5kIG5lc3RlZCByZXN1bHRzIGFyZSAkZGlydHksIHRoaXMgYWxzbyBiZWNvbWVzICRkaXJ0eVxuXG5cbiAgaWYgKGFsbFJlc3VsdHMudmFsdWUubGVuZ3RoICYmIGFsbFJlc3VsdHMudmFsdWUuZXZlcnkoZnVuY3Rpb24gKG5yKSB7XG4gICAgcmV0dXJuIG5yLiRkaXJ0eTtcbiAgfSkpICR0b3VjaCgpO1xuICByZXR1cm4ge1xuICAgICRkaXJ0eTogJGRpcnR5LFxuICAgICRlcnJvcnM6ICRlcnJvcnMsXG4gICAgJGludmFsaWQ6ICRpbnZhbGlkLFxuICAgICRhbnlEaXJ0eTogJGFueURpcnR5LFxuICAgICRlcnJvcjogJGVycm9yLFxuICAgICRwZW5kaW5nOiAkcGVuZGluZyxcbiAgICAkdG91Y2g6ICR0b3VjaCxcbiAgICAkcmVzZXQ6ICRyZXNldCxcbiAgICAkc2lsZW50RXJyb3JzOiAkc2lsZW50RXJyb3JzXG4gIH07XG59XG4vKipcbiAqIEB0eXBlZGVmIFZ1ZWxpZGF0ZVN0YXRlXG4gKiBAcHJvcGVydHkge1dyaXRhYmxlQ29tcHV0ZWRSZWY8YW55Pn0gJG1vZGVsXG4gKiBAcHJvcGVydHkge0NvbXB1dGVkUmVmPEJvb2xlYW4+fSAkZGlydHlcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8Qm9vbGVhbj59ICRlcnJvclxuICogQHByb3BlcnR5IHtDb21wdXRlZFJlZjxFcnJvck9iamVjdFtdPn0gJGVycm9yc1xuICogQHByb3BlcnR5IHtDb21wdXRlZFJlZjxCb29sZWFuPn0gJGludmFsaWRcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8Qm9vbGVhbj59ICRhbnlEaXJ0eVxuICogQHByb3BlcnR5IHtDb21wdXRlZFJlZjxCb29sZWFuPn0gJHBlbmRpbmdcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259ICR0b3VjaFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gJHJlc2V0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gJHBhdGhcbiAqIEBwcm9wZXJ0eSB7Q29tcHV0ZWRSZWY8RXJyb3JPYmplY3RbXT59ICRzaWxlbnRFcnJvcnNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFskdmFsaWRhdGVdXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbJGdldFJlc3VsdHNGb3JDaGlsZF1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIFZ1ZWxpZGF0ZVN0YXRlPn1cbiAqL1xuXG4vKipcbiAqIE1haW4gVnVlbGlkYXRlIGJvb3RzdHJhcCBmdW5jdGlvbi5cbiAqIFVzZWQgYm90aCBmb3IgQ29tcG9zaXRpb24gQVBJIGluIGBzZXR1cGAgYW5kIGZvciBHbG9iYWwgQXBwIHVzYWdlLlxuICogVXNlZCB0byBjb2xsZWN0IHZhbGlkYXRpb24gc3RhdGUsIHdoZW4gd2Fsa2luZyByZWN1cnNpdmVseSBkb3duIHRoZSBzdGF0ZSB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge09iamVjdDxOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9uPn0gcGFyYW1zLnZhbGlkYXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnN0YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5rZXldIC0gQ3VycmVudCBzdGF0ZSBwcm9wZXJ0eSBrZXkuIFVzZWQgd2hlbiBiZWluZyBjYWxsZWQgb24gbmVzdGVkIGl0ZW1zXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5wYXJlbnRLZXldIC0gUGFyZW50IHN0YXRlIHByb3BlcnR5IGtleS4gVXNlZCB3aGVuIGJlaW5nIGNhbGxlZCByZWN1cnNpdmVseVxuICogQHBhcmFtIHtPYmplY3Q8VmFsaWRhdGlvblJlc3VsdD59IFtwYXJhbXMuY2hpbGRSZXN1bHRzXSAtIFVzZWQgdG8gY29sbGVjdCBjaGlsZCByZXN1bHRzLlxuICogQHBhcmFtIHtSZXN1bHRzU3RvcmFnZX0gcGFyYW1zLnJlc3VsdHNDYWNoZSAtIFRoZSBjYWNoZWQgdmFsaWRhdGlvbiByZXN1bHRzXG4gKiBAcGFyYW0ge1Z1ZUluc3RhbmNlfSBwYXJhbXMuaW5zdGFuY2UgLSBUaGUgY3VycmVudCBWdWUgaW5zdGFuY2VcbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBwYXJhbXMuZ2xvYmFsQ29uZmlnIC0gVGhlIHZhbGlkYXRpb24gY29uZmlnLCBwYXNzZWQgdG8gdGhpcyBzZXRWYWxpZGF0aW9ucyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7UmVhY3RpdmU8b2JqZWN0PiB8IFJlZjxPYmplY3Q+fSBwYXJhbXMuZXh0ZXJuYWxSZXN1bHRzIC0gRXh0ZXJuYWwgdmFsaWRhdGlvbiByZXN1bHRzXG4gKiBAcmV0dXJuIHtVbndyYXBOZXN0ZWRSZWZzPFZ1ZWxpZGF0ZVN0YXRlPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFZhbGlkYXRpb25zKF9yZWYzKSB7XG4gIHZhciB2YWxpZGF0aW9ucyA9IF9yZWYzLnZhbGlkYXRpb25zLFxuICAgICAgc3RhdGUgPSBfcmVmMy5zdGF0ZSxcbiAgICAgIGtleSA9IF9yZWYzLmtleSxcbiAgICAgIHBhcmVudEtleSA9IF9yZWYzLnBhcmVudEtleSxcbiAgICAgIGNoaWxkUmVzdWx0cyA9IF9yZWYzLmNoaWxkUmVzdWx0cyxcbiAgICAgIHJlc3VsdHNDYWNoZSA9IF9yZWYzLnJlc3VsdHNDYWNoZSxcbiAgICAgIF9yZWYzJGdsb2JhbENvbmZpZyA9IF9yZWYzLmdsb2JhbENvbmZpZyxcbiAgICAgIGdsb2JhbENvbmZpZyA9IF9yZWYzJGdsb2JhbENvbmZpZyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRnbG9iYWxDb25maWcsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYzLmluc3RhbmNlLFxuICAgICAgZXh0ZXJuYWxSZXN1bHRzID0gX3JlZjMuZXh0ZXJuYWxSZXN1bHRzO1xuICB2YXIgcGF0aCA9IHBhcmVudEtleSA/IFwiXCIuY29uY2F0KHBhcmVudEtleSwgXCIuXCIpLmNvbmNhdChrZXkpIDoga2V5OyAvLyBTb3J0IG91dCB0aGUgdmFsaWRhdGlvbiBvYmplY3QgaW50bzpcbiAgLy8g4oCTIHJ1bGVzID0gdmFsaWRhdG9ycyBmb3IgY3VycmVudCBzdGF0ZSB0cmVlIGZyYWdtZW50XG4gIC8vIOKAlCBuZXN0ZWRWYWxpZGF0b3JzID0gbmVzdGVkIHN0YXRlIGZyYWdtZW50cyBrZXlzIHRoYXQgbWlnaHQgY29udGFpbiBtb3JlIHZhbGlkYXRvcnNcbiAgLy8g4oCTIGNvbmZpZyA9IGNvbmZpZ3VyYXRpb24gcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGlzIHN0YXRlIGZyYWdtZW50XG5cbiAgdmFyIF9zb3J0VmFsaWRhdGlvbnMgPSBzb3J0VmFsaWRhdGlvbnModmFsaWRhdGlvbnMpLFxuICAgICAgcnVsZXMgPSBfc29ydFZhbGlkYXRpb25zLnJ1bGVzLFxuICAgICAgbmVzdGVkVmFsaWRhdG9ycyA9IF9zb3J0VmFsaWRhdGlvbnMubmVzdGVkVmFsaWRhdG9ycyxcbiAgICAgIGNvbmZpZyA9IF9zb3J0VmFsaWRhdGlvbnMuY29uZmlnO1xuXG4gIHZhciBtZXJnZWRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBnbG9iYWxDb25maWcsIGNvbmZpZyk7IC8vIGNyZWF0ZSBwcm90ZWN0ZWQgc3RhdGUgZm9yIGNhc2VzIHdoZW4gdGhlIHN0YXRlIGJyYW5jaCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gIC8vIFRoaXMgcHJvdGVjdHMgd2hlbiB1c2luZyB0aGUgT3B0aW9uc0FQSSBhcyB0aGUgZGF0YSBpcyBib3VuZCBhZnRlciB0aGUgc2V0dXAgbWV0aG9kXG5cbiAgdmFyIG5lc3RlZFN0YXRlID0ga2V5ID8gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdW5yZWYoc3RhdGUpO1xuICAgIHJldHVybiBzID8gdW5yZWYoc1trZXldKSA6IHVuZGVmaW5lZDtcbiAgfSkgOiBzdGF0ZTsgLy8gY2FjaGUgdGhlIGV4dGVybmFsIHJlc3VsdHMsIHNvIHdlIGNhbiByZXZlcnQgYmFjayB0byB0aGVtXG5cbiAgdmFyIGNhY2hlZEV4dGVybmFsUmVzdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIHVucmVmKGV4dGVybmFsUmVzdWx0cykgfHwge30pO1xuICB2YXIgbmVzdGVkRXh0ZXJuYWxSZXN1bHRzID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHRzID0gdW5yZWYoZXh0ZXJuYWxSZXN1bHRzKTtcbiAgICBpZiAoIWtleSkgcmV0dXJuIHJlc3VsdHM7XG4gICAgcmV0dXJuIHJlc3VsdHMgPyB1bnJlZihyZXN1bHRzW2tleV0pIDogdW5kZWZpbmVkO1xuICB9KTsgLy8gVXNlIHJ1bGVzIGZvciB0aGUgY3VycmVudCBzdGF0ZSBmcmFnbWVudCBhbmQgdmFsaWRhdGUgaXRcblxuICB2YXIgcmVzdWx0cyA9IGNyZWF0ZVZhbGlkYXRpb25SZXN1bHRzKHJ1bGVzLCBuZXN0ZWRTdGF0ZSwga2V5LCByZXN1bHRzQ2FjaGUsIHBhdGgsIG1lcmdlZENvbmZpZywgaW5zdGFuY2UsIG5lc3RlZEV4dGVybmFsUmVzdWx0cyk7IC8vIFVzZSBuZXN0ZWQga2V5cyB0byByZXBlYXQgdGhlIHByb2Nlc3NcbiAgLy8gKldBUk4qOiBUaGlzIGlzIHJlY3Vyc2l2ZVxuXG4gIHZhciBuZXN0ZWRSZXN1bHRzID0gY29sbGVjdE5lc3RlZFZhbGlkYXRpb25SZXN1bHRzKG5lc3RlZFZhbGlkYXRvcnMsIG5lc3RlZFN0YXRlLCBwYXRoLCByZXN1bHRzQ2FjaGUsIG1lcmdlZENvbmZpZywgaW5zdGFuY2UsIG5lc3RlZEV4dGVybmFsUmVzdWx0cyk7IC8vIENvbGxlY3QgYW5kIG1lcmdlIHRoaXMgbGV2ZWwgdmFsaWRhdGlvbiByZXN1bHRzXG4gIC8vIHdpdGggYWxsIG5lc3RlZCB2YWxpZGF0aW9uIHJlc3VsdHNcblxuICB2YXIgX2NyZWF0ZU1ldGFGaWVsZHMgPSBjcmVhdGVNZXRhRmllbGRzKHJlc3VsdHMsIG5lc3RlZFJlc3VsdHMsIGNoaWxkUmVzdWx0cyksXG4gICAgICAkZGlydHkgPSBfY3JlYXRlTWV0YUZpZWxkcy4kZGlydHksXG4gICAgICAkZXJyb3JzID0gX2NyZWF0ZU1ldGFGaWVsZHMuJGVycm9ycyxcbiAgICAgICRpbnZhbGlkID0gX2NyZWF0ZU1ldGFGaWVsZHMuJGludmFsaWQsXG4gICAgICAkYW55RGlydHkgPSBfY3JlYXRlTWV0YUZpZWxkcy4kYW55RGlydHksXG4gICAgICAkZXJyb3IgPSBfY3JlYXRlTWV0YUZpZWxkcy4kZXJyb3IsXG4gICAgICAkcGVuZGluZyA9IF9jcmVhdGVNZXRhRmllbGRzLiRwZW5kaW5nLFxuICAgICAgJHRvdWNoID0gX2NyZWF0ZU1ldGFGaWVsZHMuJHRvdWNoLFxuICAgICAgJHJlc2V0ID0gX2NyZWF0ZU1ldGFGaWVsZHMuJHJlc2V0LFxuICAgICAgJHNpbGVudEVycm9ycyA9IF9jcmVhdGVNZXRhRmllbGRzLiRzaWxlbnRFcnJvcnM7XG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIG5vIGBrZXlgLCB0aGlzIGlzIHRoZSB0b3AgbGV2ZWwgc3RhdGVcbiAgICogV2UgZG9udCBuZWVkIGAkbW9kZWxgIHRoZXJlLlxuICAgKi9cblxuXG4gIHZhciAkbW9kZWwgPSBrZXkgPyBjb21wdXRlZCh7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdW5yZWYobmVzdGVkU3RhdGUpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICAkZGlydHkudmFsdWUgPSB0cnVlO1xuICAgICAgdmFyIHMgPSB1bnJlZihzdGF0ZSk7XG5cbiAgICAgIGlmIChpc1JlZihzW2tleV0pKSB7XG4gICAgICAgIHNba2V5XS52YWx1ZSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pIDogbnVsbDtcblxuICBpZiAoa2V5ICYmIG1lcmdlZENvbmZpZy4kYXV0b0RpcnR5KSB7XG4gICAgdmFyICR1bndhdGNoID0gd2F0Y2gobmVzdGVkU3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhdXRvRGlydHlQYXRoID0gXCJfXCIuY29uY2F0KHBhdGgsIFwiXyR3YXRjaGVyX1wiKTtcbiAgICAgIHZhciBjYWNoZWRBdXRvRGlydHkgPSByZXN1bHRzQ2FjaGUuZ2V0KGF1dG9EaXJ0eVBhdGgsIHt9KTtcbiAgICAgIGlmICghJGRpcnR5LnZhbHVlKSAkdG91Y2goKTtcbiAgICAgIGlmIChjYWNoZWRBdXRvRGlydHkpIGNhY2hlZEF1dG9EaXJ0eS4kdW53YXRjaCgpO1xuICAgICAgcmVzdWx0c0NhY2hlLnNldChhdXRvRGlydHlQYXRoLCB7fSwge1xuICAgICAgICAkdW53YXRjaDogJHVud2F0Y2hcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGZsdXNoOiAnc3luYydcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgdGhlIHZhbGlkYXRvcnMgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG5cblxuICBmdW5jdGlvbiAkdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKF9hc3luYyhmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgaWYgKCEkZGlydHkudmFsdWUpICR0b3VjaCgpOyAvLyBhd2FpdCB0aGUgd2F0Y2hlcnNcblxuICAgICAgcmV0dXJuIF9jYWxsKG5leHRUaWNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGl0IGlzIHZhbGlkIG9yIG5vdFxuICAgICAgICBpZiAoISRwZW5kaW5nLnZhbHVlKSByZXR1cm4gcmVzb2x2ZSghJGludmFsaWQudmFsdWUpO1xuICAgICAgICB2YXIgdW53YXRjaCA9IHdhdGNoKCRwZW5kaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZSghJGludmFsaWQudmFsdWUpO1xuICAgICAgICAgIHVud2F0Y2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjaGlsZCBjb21wb25lbnQncyByZXN1bHRzLCBiYXNlZCBvbiByZWdpc3RyYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge1Z1ZWxpZGF0ZVN0YXRlfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uICRnZXRSZXN1bHRzRm9yQ2hpbGQoa2V5KSB7XG4gICAgcmV0dXJuIChjaGlsZFJlc3VsdHMudmFsdWUgfHwge30pW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiAkY2xlYXJFeHRlcm5hbFJlc3VsdHMoKSB7XG4gICAgaWYgKGlzUmVmKGV4dGVybmFsUmVzdWx0cykpIHtcbiAgICAgIGV4dGVybmFsUmVzdWx0cy52YWx1ZSA9IGNhY2hlZEV4dGVybmFsUmVzdWx0cztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdGhlIGV4dGVybmFsIHJlc3VsdHMgc3RhdGUgd2FzIGVtcHR5LCB3ZSBuZWVkIHRvIGRlbGV0ZSBldmVyeSBwcm9wZXJ0eSwgb25lIGJ5IG9uZVxuICAgICAgaWYgKE9iamVjdC5rZXlzKGNhY2hlZEV4dGVybmFsUmVzdWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGV4dGVybmFsUmVzdWx0cykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIGRlbGV0ZSBleHRlcm5hbFJlc3VsdHNba107XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RhdGUgd2FzIG5vdCBlbXB0eSwgc28gd2UganVzdCBhc3NpZ24gaXQgYmFjayBpbnRvIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXh0ZXJuYWxSZXN1bHRzLCBjYWNoZWRFeHRlcm5hbFJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFjdGl2ZShPYmplY3QuYXNzaWduKHt9LCByZXN1bHRzLCB7XG4gICAgLy8gTk9URTogVGhlIG9yZGVyIGhlcmUgaXMgdmVyeSBpbXBvcnRhbnQsIHNpbmNlIHdlIHdhbnQgdG8gb3ZlcnJpZGVcbiAgICAvLyBzb21lIG9mIHRoZSAqcmVzdWx0cyogbWV0YSBmaWVsZHMgd2l0aCB0aGUgY29sbGVjdGl2ZSB2ZXJzaW9uIG9mIGl0XG4gICAgLy8gdGhhdCBpbmNsdWRlcyB0aGUgcmVzdWx0cyBvZiBuZXN0ZWQgc3RhdGUgdmFsaWRhdGlvbiByZXN1bHRzXG4gICAgJG1vZGVsOiAkbW9kZWwsXG4gICAgJGRpcnR5OiAkZGlydHksXG4gICAgJGVycm9yOiAkZXJyb3IsXG4gICAgJGVycm9yczogJGVycm9ycyxcbiAgICAkaW52YWxpZDogJGludmFsaWQsXG4gICAgJGFueURpcnR5OiAkYW55RGlydHksXG4gICAgJHBlbmRpbmc6ICRwZW5kaW5nLFxuICAgICR0b3VjaDogJHRvdWNoLFxuICAgICRyZXNldDogJHJlc2V0LFxuICAgICRwYXRoOiBwYXRoIHx8IFJPT1RfUEFUSCxcbiAgICAkc2lsZW50RXJyb3JzOiAkc2lsZW50RXJyb3JzXG4gIH0sIGNoaWxkUmVzdWx0cyAmJiB7XG4gICAgJGdldFJlc3VsdHNGb3JDaGlsZDogJGdldFJlc3VsdHNGb3JDaGlsZCxcbiAgICAkdmFsaWRhdGU6ICR2YWxpZGF0ZSxcbiAgICAkY2xlYXJFeHRlcm5hbFJlc3VsdHM6ICRjbGVhckV4dGVybmFsUmVzdWx0c1xuICB9LCBuZXN0ZWRSZXN1bHRzKSk7XG59XG5cbnZhciBSZXN1bHRzU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdHNTdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXN1bHRzU3RvcmFnZSk7XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3JlcyBhIHZhbGlkYXRpb24gcmVzdWx0LCBhbmQgaXRzIHJ1bGVzIGJ5IGl0cyBwYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+fSBydWxlc1xuICAgKiBAcGFyYW0ge1ZhbGlkYXRpb25SZXN1bHR9IHJlc3VsdFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhSZXN1bHRzU3RvcmFnZSwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChwYXRoLCBydWxlcywgcmVzdWx0KSB7XG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0KHBhdGgsIHtcbiAgICAgICAgcnVsZXM6IHJ1bGVzLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBzdG9yZWQgYHJlc3VsdHNgIGZvciB0aGUgcHJvdmlkZWQgYHBhdGhgIGhhdmUgdGhlIHNhbWUgYHJ1bGVzYCBjb21wYXJlZCB0byAnc3RvcmVkUnVsZXMnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcGFyYW0ge09iamVjdDxOb3JtYWxpemVkVmFsaWRhdG9yPn0gcnVsZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdDxOb3JtYWxpemVkVmFsaWRhdG9yPn0gc3RvcmVkUnVsZXNcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tSdWxlc1ZhbGlkaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUnVsZXNWYWxpZGl0eShwYXRoLCBydWxlcywgc3RvcmVkUnVsZXMpIHtcbiAgICAgIHZhciBzdG9yZWRSdWxlc0tleXMgPSBPYmplY3Qua2V5cyhzdG9yZWRSdWxlcyk7XG4gICAgICB2YXIgbmV3UnVsZXNLZXlzID0gT2JqZWN0LmtleXMocnVsZXMpO1xuICAgICAgaWYgKG5ld1J1bGVzS2V5cy5sZW5ndGggIT09IHN0b3JlZFJ1bGVzS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBoYXNBbGxWYWxpZGF0b3JzID0gbmV3UnVsZXNLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChydWxlS2V5KSB7XG4gICAgICAgIHJldHVybiBzdG9yZWRSdWxlc0tleXMuaW5jbHVkZXMocnVsZUtleSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghaGFzQWxsVmFsaWRhdG9ycykgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG5ld1J1bGVzS2V5cy5ldmVyeShmdW5jdGlvbiAocnVsZUtleSkge1xuICAgICAgICBpZiAoIXJ1bGVzW3J1bGVLZXldLiRwYXJhbXMpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocnVsZXNbcnVsZUtleV0uJHBhcmFtcykuZXZlcnkoZnVuY3Rpb24gKHBhcmFtS2V5KSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHVud3JhcCBiZWZvcmUgY29tcGFyaW5nXG4gICAgICAgICAgcmV0dXJuIHVucmVmKHN0b3JlZFJ1bGVzW3J1bGVLZXldLiRwYXJhbXNbcGFyYW1LZXldKSA9PT0gdW5yZWYocnVsZXNbcnVsZUtleV0uJHBhcmFtc1twYXJhbUtleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHJlc3VsdCBpZiBjYXRjaGUgaXMgdmFsaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PE5vcm1hbGl6ZWRWYWxpZGF0b3I+fSBydWxlc1xuICAgICAqIEByZXR1cm4ge3skcGFydGlhbDogYm9vbGVhbiwgJGRpcnR5OiBSZWY8Ym9vbGVhbj59fHVuZGVmaW5lZHxWYWxpZGF0aW9uUmVzdWx0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChwYXRoLCBydWxlcykge1xuICAgICAgdmFyIHN0b3JlZFJ1bGVSZXN1bHRQYWlyID0gdGhpcy5zdG9yYWdlLmdldChwYXRoKTtcbiAgICAgIGlmICghc3RvcmVkUnVsZVJlc3VsdFBhaXIpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc3RvcmVkUnVsZXMgPSBzdG9yZWRSdWxlUmVzdWx0UGFpci5ydWxlcyxcbiAgICAgICAgICByZXN1bHQgPSBzdG9yZWRSdWxlUmVzdWx0UGFpci5yZXN1bHQ7XG4gICAgICB2YXIgaXNWYWxpZENhY2hlID0gdGhpcy5jaGVja1J1bGVzVmFsaWRpdHkocGF0aCwgcnVsZXMsIHN0b3JlZFJ1bGVzKTtcbiAgICAgIHZhciAkdW53YXRjaCA9IHJlc3VsdC4kdW53YXRjaCA/IHJlc3VsdC4kdW53YXRjaCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfTtcbiAgICAgIGlmICghaXNWYWxpZENhY2hlKSByZXR1cm4ge1xuICAgICAgICAkZGlydHk6IHJlc3VsdC4kZGlydHksXG4gICAgICAgICRwYXJ0aWFsOiB0cnVlLFxuICAgICAgICAkdW53YXRjaDogJHVud2F0Y2hcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXN1bHRzU3RvcmFnZTtcbn0oKTtcblxudmFyIFZ1ZWxpZGF0ZUluamVjdENoaWxkUmVzdWx0cyA9IFN5bWJvbCgndnVlbGlkYXRlI2luamVjdENoaWlsZFJlc3VsdHMnKTtcbnZhciBWdWVsaWRhdGVSZW1vdmVDaGlsZFJlc3VsdHMgPSBTeW1ib2woJ3Z1ZWxpZGF0ZSNyZW1vdmVDaGlpbGRSZXN1bHRzJyk7XG52YXIgQ29sbGVjdEZsYWcgPSB7XG4gIENPTExFQ1RfQUxMOiB0cnVlLFxuICBDT0xMRUNUX05PTkU6IGZhbHNlXG59O1xuLyoqXG4gKiBDcmVhdGUgaGVscGVycyB0byBjb2xsZWN0IHZhbGlkYXRpb24gc3RhdGUgZnJvbSBjaGlsZCBjb21wb25lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gcGFyYW1zLiRzY29wZSAtIFBhcmVudCBjb21wb25lbnQgc2NvcGVcbiAqIEByZXR1cm4ge3tzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudDogZnVuY3Rpb24sIGNoaWxkUmVzdWx0czogQ29tcHV0ZWRSZWY8T2JqZWN0PiwgcmVtb3ZlVmFsaWRhdGlvblJlc3VsdHNGcm9tUGFyZW50OiBmdW5jdGlvbn19XG4gKi9cblxuZnVuY3Rpb24gbmVzdGVkVmFsaWRhdGlvbnMoX3JlZikge1xuICB2YXIgJHNjb3BlID0gX3JlZi4kc2NvcGU7XG4gIHZhciBjaGlsZFJlc3VsdHNSYXcgPSB7fTtcbiAgdmFyIGNoaWxkUmVzdWx0c0tleXMgPSByZWYoW10pO1xuICB2YXIgY2hpbGRSZXN1bHRzID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGlsZFJlc3VsdHNLZXlzLnZhbHVlLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0cywga2V5KSB7XG4gICAgICByZXN1bHRzW2tleV0gPSB1bnJlZihjaGlsZFJlc3VsdHNSYXdba2V5XSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LCB7fSk7XG4gIH0pO1xuICAvKipcbiAgICogQWxsb3dzIGNoaWxkcmVuIHRvIHNlbmQgdmFsaWRhdGlvbiBkYXRhIHVwIHRvIHRoZWlyIHBhcmVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdHMgLSB0aGUgcmVzdWx0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXJncy4kcmVnaXN0ZXJBcyAtIHRoZSAkcmVnaXN0ZXJlZEFzIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gYXJncy4kc2NvcGUgLSB0aGUgJHNjb3BlIGtleVxuICAgKi9cblxuICBmdW5jdGlvbiBpbmplY3RDaGlsZFJlc3VsdHNJbnRvUGFyZW50KHJlc3VsdHMsIF9yZWYyKSB7XG4gICAgdmFyIGtleSA9IF9yZWYyLiRyZWdpc3RlckFzLFxuICAgICAgICBjaGlsZFNjb3BlID0gX3JlZjIuJHNjb3BlLFxuICAgICAgICAkc3RvcFByb3BhZ2F0aW9uID0gX3JlZjIuJHN0b3BQcm9wYWdhdGlvbjtcbiAgICBpZiAoJHN0b3BQcm9wYWdhdGlvbiB8fCAkc2NvcGUgPT09IENvbGxlY3RGbGFnLkNPTExFQ1RfTk9ORSB8fCBjaGlsZFNjb3BlID09PSBDb2xsZWN0RmxhZy5DT0xMRUNUX05PTkUgfHwgJHNjb3BlICE9PSBDb2xsZWN0RmxhZy5DT0xMRUNUX0FMTCAmJiAkc2NvcGUgIT09IGNoaWxkU2NvcGUpIHJldHVybjtcbiAgICBjaGlsZFJlc3VsdHNSYXdba2V5XSA9IHJlc3VsdHM7XG4gICAgY2hpbGRSZXN1bHRzS2V5cy52YWx1ZS5wdXNoKGtleSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyBjaGlsZHJlbiB0byByZW1vdmUgdGhlIHZhbGlkYXRpb24gZGF0YSBmcm9tIHRoZWlyIHBhcmVudCwgYmVmb3JlIGdldHRpbmcgZGVzdHJveWVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdGhlIHJlZ2lzdGVyZWRBcyBrZXlcbiAgICovXG5cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlc3VsdHNGcm9tUGFyZW50KGtleSkge1xuICAgIC8vIHJlbW92ZSB0aGUga2V5XG4gICAgY2hpbGRSZXN1bHRzS2V5cy52YWx1ZSA9IGNoaWxkUmVzdWx0c0tleXMudmFsdWUuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZEtleSkge1xuICAgICAgcmV0dXJuIGNoaWxkS2V5ICE9PSBrZXk7XG4gICAgfSk7IC8vIHJlbW92ZSB0aGUgc3RvcmVkIGRhdGEgZm9yIHRoZSBrZXlcblxuICAgIGRlbGV0ZSBjaGlsZFJlc3VsdHNSYXdba2V5XTtcbiAgfSAvLyBpbmplY3QgdGhlIGBpbmplY3RDaGlsZFJlc3VsdHNJbnRvUGFyZW50YCBtZXRob2QsIGludG8gdGhlIGN1cnJlbnQgc2NvcGVcblxuXG4gIHZhciBzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudCA9IGluamVjdChWdWVsaWRhdGVJbmplY3RDaGlsZFJlc3VsdHMsIGZ1bmN0aW9uICgpIHt9KTsgLy8gcHJvdmlkZSB0byBhbGwgb2YgaXRzIGNoaWxkcmVuIHRoZSBzZW5kIHJlc3VsdHMgdG8gcGFyZW50IGZ1bmN0aW9uXG5cbiAgcHJvdmlkZShWdWVsaWRhdGVJbmplY3RDaGlsZFJlc3VsdHMsIGluamVjdENoaWxkUmVzdWx0c0ludG9QYXJlbnQpO1xuICB2YXIgcmVtb3ZlVmFsaWRhdGlvblJlc3VsdHNGcm9tUGFyZW50ID0gaW5qZWN0KFZ1ZWxpZGF0ZVJlbW92ZUNoaWxkUmVzdWx0cywgZnVuY3Rpb24gKCkge30pOyAvLyBwcm92aWRlIHRvIGFsbCBvZiBpdHMgY2hpbGRyZW4gdGhlIHJlbW92ZSByZXN1bHRzICBmdW5jdGlvblxuXG4gIHByb3ZpZGUoVnVlbGlkYXRlUmVtb3ZlQ2hpbGRSZXN1bHRzLCByZW1vdmVDaGlsZFJlc3VsdHNGcm9tUGFyZW50KTtcbiAgcmV0dXJuIHtcbiAgICBjaGlsZFJlc3VsdHM6IGNoaWxkUmVzdWx0cyxcbiAgICBzZW5kVmFsaWRhdGlvblJlc3VsdHNUb1BhcmVudDogc2VuZFZhbGlkYXRpb25SZXN1bHRzVG9QYXJlbnQsXG4gICAgcmVtb3ZlVmFsaWRhdGlvblJlc3VsdHNGcm9tUGFyZW50OiByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnRcbiAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2xvYmFsQ29uZmlnXG4gKiBAcHJvcGVydHkge1N0cmluZ30gWyRyZWdpc3RlckFzXSAtIENvbmZpZyBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nIHwgTnVtYmVyIHwgU3ltYm9sfSBbJHNjb3BlXSAtIEEgc2NvcGUgdG8gbGltaXQgY2hpbGQgY29tcG9uZW50IHJlZ2lzdHJhdGlvblxuICogQHByb3BlcnR5IHtCb29sZWFufSBbJHN0b3BQcm9wYWdhdGlvbl0gLSBUZWxscyBhIFZ1ZSBjb21wb25lbnQgdG8gc3RvcCBzZW5kaW5nIGl0cyByZXN1bHRzIHVwIHRvIHRoZSBwYXJlbnRcbiAqIEBwcm9wZXJ0eSB7UmVmPE9iamVjdD59IFskZXh0ZXJuYWxSZXN1bHRzXSAtIEV4dGVybmFsIGVycm9yIG1lc3NhZ2VzLCBsaWtlIGZyb20gc2VydmVyIHZhbGlkYXRpb24uXG4gKi9cblxuLyoqXG4gKiBDb21wb3NpdGlvbiBBUEkgY29tcGF0aWJsZSBWdWVsaWRhdGVcbiAqIFVzZSBpbnNpZGUgdGhlIGBzZXR1cGAgbGlmZWN5Y2xlIGhvb2tcbiAqIEBwYXJhbSB7T2JqZWN0IHwgR2xvYmFsQ29uZmlnfSBbdmFsaWRhdGlvbnNdIC0gVmFsaWRhdGlvbnMgT2JqZWN0IG9yIHRoZSBnbG9iYWxDb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YXRlXSAtIFN0YXRlIG9iamVjdCAtIHJlcXVpcmVkIGlmIGB2YWxpZGF0aW9uc2AgaXMgYSB2YWxpZGF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7R2xvYmFsQ29uZmlnfSBbZ2xvYmFsQ29uZmlnXSAtIENvbmZpZyBPYmplY3RcbiAqIEByZXR1cm4ge1Vud3JhcFJlZjwqPn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVZ1ZWxpZGF0ZSh2YWxpZGF0aW9ucywgc3RhdGUpIHtcbiAgdmFyIGdsb2JhbENvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgLy8gaWYgd2UgcGFzcyBvbmx5IG9uZSBhcmd1bWVudCwgaXRzIG1vc3QgcHJvYmFibHkgdGhlIGdsb2JhbENvbmZpZy5cbiAgLy8gVGhpcyB1c2UgY2FzZSBpcyBzbyBwYXJlbnRzIGNhbiBqdXN0IGNvbGxlY3QgcmVzdWx0cyBvZiBjaGlsZCBmb3Jtcy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBnbG9iYWxDb25maWcgPSB2YWxpZGF0aW9ucztcbiAgICB2YWxpZGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBfZ2xvYmFsQ29uZmlnID0gZ2xvYmFsQ29uZmlnLFxuICAgICAgJHJlZ2lzdGVyQXMgPSBfZ2xvYmFsQ29uZmlnLiRyZWdpc3RlckFzLFxuICAgICAgX2dsb2JhbENvbmZpZyQkc2NvcGUgPSBfZ2xvYmFsQ29uZmlnLiRzY29wZSxcbiAgICAgICRzY29wZSA9IF9nbG9iYWxDb25maWckJHNjb3BlID09PSB2b2lkIDAgPyBDb2xsZWN0RmxhZy5DT0xMRUNUX0FMTCA6IF9nbG9iYWxDb25maWckJHNjb3BlLFxuICAgICAgJHN0b3BQcm9wYWdhdGlvbiA9IF9nbG9iYWxDb25maWcuJHN0b3BQcm9wYWdhdGlvbixcbiAgICAgICRleHRlcm5hbFJlc3VsdHMgPSBfZ2xvYmFsQ29uZmlnLiRleHRlcm5hbFJlc3VsdHM7XG4gIHZhciBpbnN0YW5jZSA9IGdldEN1cnJlbnRJbnN0YW5jZSgpO1xuICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IGluc3RhbmNlID8gaXNWdWUzID8gaW5zdGFuY2UudHlwZSA6IGluc3RhbmNlLnByb3h5LiRvcHRpb25zIDoge307IC8vIGlmIHRoZXJlIGlzIG5vIHJlZ2lzdHJhdGlvbiBuYW1lLCBhZGQgb25lLlxuXG4gIGlmICghJHJlZ2lzdGVyQXMgJiYgaW5zdGFuY2UpIHtcbiAgICAvLyBOT1RFOlxuICAgIC8vIC5fdWlkIC8vIFZ1ZSAyLnggQ29tcG9zaXRpb24tQVBJIHBsdWdpblxuICAgIC8vIC51aWQgLy8gVnVlIDMuMFxuICAgIHZhciB1aWQgPSBpbnN0YW5jZS51aWQgfHwgaW5zdGFuY2UuX3VpZDtcbiAgICAkcmVnaXN0ZXJBcyA9IFwiX3Z1ZWxpZGF0ZV9cIi5jb25jYXQodWlkKTtcbiAgfVxuXG4gIHZhciB2YWxpZGF0aW9uUmVzdWx0cyA9IHJlZih7fSk7XG4gIHZhciByZXN1bHRzQ2FjaGUgPSBuZXcgUmVzdWx0c1N0b3JhZ2UoKTtcblxuICB2YXIgX3JlZjMgPSBpbnN0YW5jZSA/IG5lc3RlZFZhbGlkYXRpb25zKHtcbiAgICAkc2NvcGU6ICRzY29wZVxuICB9KSA6IHtcbiAgICBjaGlsZFJlc3VsdHM6IHJlZih7fSlcbiAgfSxcbiAgICAgIGNoaWxkUmVzdWx0cyA9IF9yZWYzLmNoaWxkUmVzdWx0cyxcbiAgICAgIHNlbmRWYWxpZGF0aW9uUmVzdWx0c1RvUGFyZW50ID0gX3JlZjMuc2VuZFZhbGlkYXRpb25SZXN1bHRzVG9QYXJlbnQsXG4gICAgICByZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnQgPSBfcmVmMy5yZW1vdmVWYWxpZGF0aW9uUmVzdWx0c0Zyb21QYXJlbnQ7IC8vIE9wdGlvbnMgQVBJXG5cblxuICBpZiAoIXZhbGlkYXRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMudmFsaWRhdGlvbnMpIHtcbiAgICB2YXIgcnVsZXMgPSBjb21wb25lbnRPcHRpb25zLnZhbGlkYXRpb25zO1xuICAgIHN0YXRlID0gcmVmKHt9KTtcbiAgICBvbkJlZm9yZU1vdW50KGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIERlbGF5IGJpbmRpbmcgc3RhdGUgdG8gdmFsaWRhdGlvbnMgZGVmaW5lZCB3aXRoIHRoZSBPcHRpb25zIEFQSSB1bnRpbCBtb3VudGluZywgd2hlbiB0aGUgZGF0YVxuICAgICAgLy8gaGFzIGJlZW4gYXR0YWNoZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gRnJvbSB0aGF0IHBvaW50IG9uIGl0IHdpbGwgYmUgcmVhY3RpdmUuXG4gICAgICBzdGF0ZS52YWx1ZSA9IGluc3RhbmNlLnByb3h5OyAvLyBoZWxwZXIgcHJveHkgZm9yIGluc3RhbmNlIHByb3BlcnR5IGFjY2Vzcy4gSXQgbWFrZXMgZXZlcnkgcmVmZXJlbmNlXG4gICAgICAvLyByZWFjdGl2ZSBmb3IgdGhlIHZhbGlkYXRpb24gZnVuY3Rpb25cblxuICAgICAgZnVuY3Rpb24gQ29tcHV0ZWRQcm94eUZhY3RvcnkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIF90eXBlb2YodGFyZ2V0W3Byb3BdKSA9PT0gJ29iamVjdCcgPyBDb21wdXRlZFByb3h5RmFjdG9yeSh0YXJnZXRbcHJvcF0pIDogY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihydWxlcykgPyBydWxlcy5jYWxsKHN0YXRlLnZhbHVlLCBuZXcgQ29tcHV0ZWRQcm94eUZhY3Rvcnkoc3RhdGUudmFsdWUpKSA6IHJ1bGVzO1xuICAgICAgfSwgZnVuY3Rpb24gKHZhbGlkYXRpb25zKSB7XG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHRzLnZhbHVlID0gc2V0VmFsaWRhdGlvbnMoe1xuICAgICAgICAgIHZhbGlkYXRpb25zOiB2YWxpZGF0aW9ucyxcbiAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgY2hpbGRSZXN1bHRzOiBjaGlsZFJlc3VsdHMsXG4gICAgICAgICAgcmVzdWx0c0NhY2hlOiByZXN1bHRzQ2FjaGUsXG4gICAgICAgICAgZ2xvYmFsQ29uZmlnOiBnbG9iYWxDb25maWcsXG4gICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLnByb3h5LFxuICAgICAgICAgIGV4dGVybmFsUmVzdWx0czogaW5zdGFuY2UucHJveHkudnVlbGlkYXRlRXh0ZXJuYWxSZXN1bHRzXG4gICAgICAgIH0pO1xuICAgICAgfSwge1xuICAgICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGdsb2JhbENvbmZpZyA9IGNvbXBvbmVudE9wdGlvbnMudmFsaWRhdGlvbnNDb25maWcgfHwge307XG4gIH0gZWxzZSB7XG4gICAgdmFyIHZhbGlkYXRpb25zV2F0Y2hUYXJnZXQgPSBpc1JlZih2YWxpZGF0aW9ucykgfHwgaXNQcm94eSh2YWxpZGF0aW9ucykgPyB2YWxpZGF0aW9ucyAvLyB3cmFwIHBsYWluIG9iamVjdHMgaW4gYSByZWFjdGl2ZSwgc28gd2UgY2FuIHRyYWNrIGNoYW5nZXMgaWYgdGhleSBoYXZlIGNvbXB1dGVkIGluIHRoZW0uXG4gICAgOiByZWFjdGl2ZSh2YWxpZGF0aW9ucyB8fCB7fSk7XG4gICAgd2F0Y2godmFsaWRhdGlvbnNXYXRjaFRhcmdldCwgZnVuY3Rpb24gKG5ld1ZhbGlkYXRpb25SdWxlcykge1xuICAgICAgdmFsaWRhdGlvblJlc3VsdHMudmFsdWUgPSBzZXRWYWxpZGF0aW9ucyh7XG4gICAgICAgIHZhbGlkYXRpb25zOiBuZXdWYWxpZGF0aW9uUnVsZXMsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgY2hpbGRSZXN1bHRzOiBjaGlsZFJlc3VsdHMsXG4gICAgICAgIHJlc3VsdHNDYWNoZTogcmVzdWx0c0NhY2hlLFxuICAgICAgICBnbG9iYWxDb25maWc6IGdsb2JhbENvbmZpZyxcbiAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlID8gaW5zdGFuY2UucHJveHkgOiB7fSxcbiAgICAgICAgZXh0ZXJuYWxSZXN1bHRzOiAkZXh0ZXJuYWxSZXN1bHRzXG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBpbW1lZGlhdGU6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIC8vIHNlbmQgYWxsIHRoZSBkYXRhIHRvIHRoZSBwYXJlbnQgd2hlbiB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCBpbnNpZGUgc2V0dXAuXG4gICAgc2VuZFZhbGlkYXRpb25SZXN1bHRzVG9QYXJlbnQodmFsaWRhdGlvblJlc3VsdHMsIHtcbiAgICAgICRyZWdpc3RlckFzOiAkcmVnaXN0ZXJBcyxcbiAgICAgICRzY29wZTogJHNjb3BlLFxuICAgICAgJHN0b3BQcm9wYWdhdGlvbjogJHN0b3BQcm9wYWdhdGlvblxuICAgIH0pOyAvLyBiZWZvcmUgdGhpcyBjb21wb25lbnQgaXMgZGVzdHJveWVkLCByZW1vdmUgYWxsIHRoZSBkYXRhIGZyb20gdGhlIHBhcmVudC5cblxuICAgIG9uQmVmb3JlVW5tb3VudChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVtb3ZlVmFsaWRhdGlvblJlc3VsdHNGcm9tUGFyZW50KCRyZWdpc3RlckFzKTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDaGFuZ2UgaW50byByZWFjdGl2ZSArIHdhdGNoXG5cblxuICByZXR1cm4gY29tcHV0ZWQoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB1bnJlZih2YWxpZGF0aW9uUmVzdWx0cy52YWx1ZSksIGNoaWxkUmVzdWx0cy52YWx1ZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VWdWVsaWRhdGU7XG5leHBvcnQgeyBDb2xsZWN0RmxhZywgdXNlVnVlbGlkYXRlIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@vuelidate/core/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/@vuelidate/validators/dist/index.esm.js":
/*!**************************************************************!*\
  !*** ./node_modules/@vuelidate/validators/dist/index.esm.js ***!
  \**************************************************************/
/*! exports provided: alpha, alphaNum, and, between, createI18nMessage, decimal, email, helpers, integer, ipAddress, macAddress, maxLength, maxValue, minLength, minValue, not, numeric, or, required, requiredIf, requiredUnless, sameAs, url */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha\", function() { return alpha$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alphaNum\", function() { return alphaNum$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"and\", function() { return and$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"between\", function() { return between$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createI18nMessage\", function() { return createI18nMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decimal\", function() { return decimal$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"email\", function() { return email$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"helpers\", function() { return common; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"integer\", function() { return integer$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ipAddress\", function() { return ipAddress$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"macAddress\", function() { return macAddress$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maxLength\", function() { return maxLength$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"maxValue\", function() { return maxValue$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minLength\", function() { return minLength$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minValue\", function() { return minValue$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"not\", function() { return not$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numeric\", function() { return numeric$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"or\", function() { return or$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"required\", function() { return required$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requiredIf\", function() { return requiredIf$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requiredUnless\", function() { return requiredUnless$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sameAs\", function() { return sameAs$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"url\", function() { return url$1; });\n/* harmony import */ var vue_demi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-demi */ \"./node_modules/vue-demi/lib/index.esm.js\");\n\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\nfunction isObject(o) {\n  return o !== null && _typeof(o) === 'object' && !Array.isArray(o);\n}\n/**\n * Returns a standard ValidatorObject\n * Wraps a plain function into a ValidatorObject\n * @param {NormalizedValidator|Function} validator\n * @return {NormalizedValidator}\n */\n\nfunction normalizeValidatorObject(validator) {\n  return isFunction(validator.$validator) ? Object.assign({}, validator) : {\n    $validator: validator\n  };\n}\nfunction isPromise(object) {\n  return isObject(object) && isFunction(object.then);\n}\n/**\n * Unwraps a ValidatorResponse object, into a boolean.\n * @param {ValidatorResponse} result\n * @return {boolean}\n */\n\nfunction unwrapValidatorResponse(result) {\n  if (_typeof(result) === 'object') return result.$valid;\n  return result;\n}\n/**\n * Unwraps a `NormalizedValidator` object, returning its validator function.\n * @param {NormalizedValidator | Function} validator\n * @return {function}\n */\n\nfunction unwrapNormalizedValidator(validator) {\n  return validator.$validator || validator;\n}\n\n/**\n * Allows attaching parameters to a validator\n * @param {Object} $params\n * @param {NormalizedValidator|Function} $validator\n * @return {NormalizedValidator}\n */\n\nfunction withParams($params, $validator) {\n  if (!isObject($params)) throw new Error(\"[@vuelidate/validators]: First parameter to \\\"withParams\\\" should be an object, provided \".concat(_typeof($params)));\n  if (!isObject($validator) && !isFunction($validator)) throw new Error(\"[@vuelidate/validators]: Validator must be a function or object with $validator parameter\");\n  var validatorObj = normalizeValidatorObject($validator);\n  validatorObj.$params = Object.assign({}, validatorObj.$params || {}, $params);\n  return validatorObj;\n}\n\n/**\n * @callback MessageCallback\n * @param {Object} params\n * @return String\n */\n\n/**\n * Attaches a message to a validator\n * @param {MessageCallback | String} $message\n * @param {NormalizedValidator|Function} $validator\n * @return {NormalizedValidator}\n */\n\nfunction withMessage($message, $validator) {\n  if (!isFunction($message) && typeof Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])($message) !== 'string') throw new Error(\"[@vuelidate/validators]: First parameter to \\\"withMessage\\\" should be string or a function returning a string, provided \".concat(_typeof($message)));\n  if (!isObject($validator) && !isFunction($validator)) throw new Error(\"[@vuelidate/validators]: Validator must be a function or object with $validator parameter\");\n  var validatorObj = normalizeValidatorObject($validator);\n  validatorObj.$message = $message;\n  return validatorObj;\n}\n\n/**\n * @typedef {function(*): Promise<boolean|ValidatorResponse>} asyncValidator\n */\n\n/**\n * @typedef {Ref<*>[]|function(*): *} watchTargets\n */\n\n/**\n * Wraps validators that returns a Promise.\n * @param {asyncValidator} $validator\n * @param {watchTargets} $watchTargets\n * @return {{$async: boolean, $validator: asyncValidator, $watchTargets: watchTargets}}\n */\n\nfunction withAsync($validator) {\n  var $watchTargets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var validatorObj = normalizeValidatorObject($validator);\n  return Object.assign({}, validatorObj, {\n    $async: true,\n    $watchTargets: $watchTargets\n  });\n}\n\nfunction forEach(validators) {\n  return {\n    $validator: function $validator(collection) {\n      var _this = this;\n\n      for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        others[_key - 1] = arguments[_key];\n      }\n\n      // go over the collection. It can be a ref as well.\n      return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(collection).reduce(function (previous, object) {\n        // go over each property\n        var collectionEntryResult = Object.entries(object).reduce(function (all, _ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              $model = _ref2[1];\n\n          // get the validators for this property\n          var innerValidators = validators[key]; // go over each validator and run it\n\n          var propertyResult = Object.entries(innerValidators).reduce(function (all, _ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                validatorName = _ref4[0],\n                currentValidator = _ref4[1];\n\n            // extract the validator. Supports simple and extended validators.\n            var validatorFunction = unwrapNormalizedValidator(currentValidator); // Call the validator with correct parameters\n\n            var $response = validatorFunction.call.apply(validatorFunction, [_this, $model].concat(others)); // extract the valid from the result\n\n            var $valid = unwrapValidatorResponse($response); // store the entire response for later\n\n            all.$data[validatorName] = $response; // if not valid, get the $message\n\n            if (!$valid) {\n              var $message = currentValidator.$message || '';\n              var $params = currentValidator.$params || {}; // If $message is a function, we call it with the appropriate parameters\n\n              if (typeof $message === 'function') {\n                $message = $message({\n                  $pending: false,\n                  $invalid: !$valid,\n                  $params: $params,\n                  $model: $model,\n                  $response: $response\n                });\n              } // save the error object\n\n\n              all.$errors.push({\n                $property: key,\n                $message: $message,\n                $params: $params,\n                $response: $response,\n                $model: $model,\n                $pending: false,\n                $validator: validatorName\n              });\n            }\n\n            return {\n              $valid: all.$valid && $valid,\n              $data: all.$data,\n              $errors: all.$errors\n            };\n          }, {\n            $valid: true,\n            $data: {},\n            $errors: []\n          });\n          all.$data[key] = propertyResult.$data;\n          all.$errors[key] = propertyResult.$errors;\n          return {\n            $valid: all.$valid && propertyResult.$valid,\n            $data: all.$data,\n            $errors: all.$errors\n          };\n        }, {\n          $valid: true,\n          $data: {},\n          $errors: {}\n        });\n        return {\n          $valid: previous.$valid && collectionEntryResult.$valid,\n          $data: previous.$data.concat(collectionEntryResult.$data),\n          $errors: previous.$errors.concat(collectionEntryResult.$errors)\n        };\n      }, {\n        $valid: true,\n        $data: [],\n        $errors: []\n      });\n    },\n    // collect all the validation errors into a 2 dimensional array, for each entry in the collection, you have an array of error messages.\n    $message: function $message(_ref5) {\n      var $response = _ref5.$response;\n      return $response ? $response.$errors.map(function (context) {\n        return Object.values(context).map(function (errors) {\n          return errors.map(function (error) {\n            return error.$message;\n          });\n        }).reduce(function (a, b) {\n          return a.concat(b);\n        }, []);\n      }) : [];\n    }\n  };\n}\n\nvar req = function req(value) {\n  value = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(value);\n  if (Array.isArray(value)) return !!value.length;\n\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  if (value === false) {\n    return true;\n  }\n\n  if (value instanceof Date) {\n    // invalid date won't pass\n    return !isNaN(value.getTime());\n  }\n\n  if (_typeof(value) === 'object') {\n    for (var _ in value) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return !!String(value).length;\n};\n/**\n * Returns the length of an arbitrary value\n * @param {Array|Object|String} value\n * @return {number}\n */\n\nvar len = function len(value) {\n  value = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(value);\n  if (Array.isArray(value)) return value.length;\n\n  if (_typeof(value) === 'object') {\n    return Object.keys(value).length;\n  }\n\n  return String(value).length;\n};\n/**\n * Regex based validator template\n * @param {RegExp} expr\n * @return {function(*=): boolean}\n */\n\nfunction regex(expr) {\n  return function (value) {\n    value = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(value);\n    return !req(value) || expr.test(value);\n  };\n}\n\n\n\nvar common = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  withParams: withParams,\n  withMessage: withMessage,\n  withAsync: withAsync,\n  forEach: forEach,\n  req: req,\n  len: len,\n  regex: regex,\n  unwrap: vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"],\n  unwrapNormalizedValidator: unwrapNormalizedValidator,\n  unwrapValidatorResponse: unwrapValidatorResponse,\n  normalizeValidatorObject: normalizeValidatorObject\n});\n\nvar alpha = regex(/^[a-zA-Z]*$/);\n\n/**\n * Validate if value is alphabetical string.\n * @type {NormalizedValidator}\n */\n\nvar alpha$1 = {\n  $validator: alpha,\n  $message: 'The value is not alphabetical',\n  $params: {\n    type: 'alpha'\n  }\n};\n\nvar alphaNum = regex(/^[a-zA-Z0-9]*$/);\n\n/**\n * Validate if value is alpha-numeric string.\n * @type {NormalizedValidator}\n */\n\nvar alphaNum$1 = {\n  $validator: alphaNum,\n  $message: 'The value must be alpha-numeric',\n  $params: {\n    type: 'alphaNum'\n  }\n};\n\nvar numeric = regex(/^\\d*(\\.\\d+)?$/);\n\n/**\n * Check whether a value is numeric.\n * @type NormalizedValidator\n */\n\nvar numeric$1 = {\n  $validator: numeric,\n  $message: 'Value must be numeric',\n  $params: {\n    type: 'numeric'\n  }\n};\n\n/**\n * Check if a numeric value is between two values.\n * @param {Ref<Number> | Number} min\n * @param {Ref<Number> | Number} max\n * @return {function(*=): boolean}\n */\n\nfunction between (min, max) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(min) <= +value && +Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(max) >= +value;\n  };\n}\n\n/**\n * Checks if a value is between two values.\n * @param {Ref<Number> | Number} min\n * @param {Ref<Number> | Number} max\n * @return {NormalizedValidator}\n */\n\nfunction between$1 (min, max) {\n  return {\n    $validator: between(min, max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The value must be between \".concat($params.min, \" and \").concat($params.max);\n    },\n    $params: {\n      min: min,\n      max: max,\n      type: 'between'\n    }\n  };\n}\n\nvar emailRegex = /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nvar email = regex(emailRegex);\n\n/**\n * Validate if value is an email.\n * @type {NormalizedValidator}\n */\n\nvar email$1 = {\n  $validator: email,\n  $message: 'Value is not a valid email address',\n  $params: {\n    type: 'email'\n  }\n};\n\n/**\n * Check if a string is an IP Address\n * @param {String} value\n * @returns {boolean}\n */\n\nfunction ipAddress (value) {\n  if (!req(value)) {\n    return true;\n  }\n\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  var nibbles = value.split('.');\n  return nibbles.length === 4 && nibbles.every(nibbleValid);\n}\n\nvar nibbleValid = function nibbleValid(nibble) {\n  if (nibble.length > 3 || nibble.length === 0) {\n    return false;\n  }\n\n  if (nibble[0] === '0' && nibble !== '0') {\n    return false;\n  }\n\n  if (!nibble.match(/^\\d+$/)) {\n    return false;\n  }\n\n  var numeric = +nibble | 0;\n  return numeric >= 0 && numeric <= 255;\n};\n\n/**\n * Validate if value is an ipAddress string.\n * @type {NormalizedValidator}\n */\n\nvar ipAddress$1 = {\n  $validator: ipAddress,\n  $message: 'The value is not a valid IP address',\n  $params: {\n    type: 'ipAddress'\n  }\n};\n\n/**\n * Check if value is a properly formatted Mac Address.\n * @param {String | Ref<String>} [separator]\n * @returns {function(*): boolean}\n */\n\nfunction macAddress () {\n  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':';\n  return function (value) {\n    separator = Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(separator);\n\n    if (!req(value)) {\n      return true;\n    }\n\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    var parts = typeof separator === 'string' && separator !== '' ? value.split(separator) : value.length === 12 || value.length === 16 ? value.match(/.{2}/g) : null;\n    return parts !== null && (parts.length === 6 || parts.length === 8) && parts.every(hexValid);\n  };\n}\n\nvar hexValid = function hexValid(hex) {\n  return hex.toLowerCase().match(/^[0-9a-f]{2}$/);\n};\n\n/**\n * Validate if value is a valid Mac Address string.\n * @returns {NormalizedValidator}\n */\n\nfunction macAddress$1 (separator) {\n  return {\n    $validator: macAddress(separator),\n    $message: 'The value is not a valid MAC Address',\n    $params: {\n      type: 'macAddress'\n    }\n  };\n}\n\n/**\n * Check if provided value has a maximum length\n * @param {Number | Ref<Number>} length\n * @returns {function(Array|Object|String): boolean}\n */\n\nfunction maxLength (length) {\n  return function (value) {\n    return !req(value) || len(value) <= Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(length);\n  };\n}\n\n/**\n * Validate the max length of a string.\n * @param {Number} max\n * @return {NormalizedValidator}\n */\n\nfunction maxLength$1 (max) {\n  return {\n    $validator: maxLength(max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The maximum length allowed is \".concat($params.max);\n    },\n    $params: {\n      max: max,\n      type: 'maxLength'\n    }\n  };\n}\n\n/**\n * Check if value is above a threshold.\n * @param {Number | Ref<Number>} length\n * @returns {function(Array|Object|String): boolean}\n */\n\nfunction minLength (length) {\n  return function (value) {\n    return !req(value) || len(value) >= Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(length);\n  };\n}\n\n/**\n * Check if value is above a threshold.\n * @param {Number | Ref<Number>} min\n * @returns {NormalizedValidator}\n */\n\nfunction minLength$1 (min) {\n  return {\n    $validator: minLength(min),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"This field should be at least \".concat($params.min, \" long\");\n    },\n    $params: {\n      min: min,\n      type: 'minLength'\n    }\n  };\n}\n\n/**\n * Validates if a value is empty.\n * @param {String | Array | Date | Object} value\n * @returns {boolean}\n */\n\nfunction required (value) {\n  if (typeof value === 'string') {\n    value = value.trim();\n  }\n\n  return req(value);\n}\n\n/**\n * Check if a value is empty or not.\n * @type {NormalizedValidator}\n */\n\nvar required$1 = {\n  $validator: required,\n  $message: 'Value is required',\n  $params: {\n    type: 'required'\n  }\n};\n\nvar validate = function validate(prop, val) {\n  return prop ? req(val) : true;\n};\n/**\n * Returns required if the passed property is truthy\n * @param {Boolean | String | function(any): Boolean | Ref<string | boolean>} propOrFunction\n * @return {function(value: *, parentVM: object): Boolean}\n */\n\n\nfunction requiredIf(propOrFunction) {\n  return function (value, parentVM) {\n    if (typeof propOrFunction !== 'function') {\n      return validate(Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(propOrFunction), value);\n    }\n\n    var result = propOrFunction.call(this, value, parentVM);\n    return validate(result, value);\n  };\n}\n\n/**\n * Returns required if the passed property is truthy\n * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop\n * @return {NormalizedValidator}\n */\n\nfunction requiredIf$1 (prop) {\n  return {\n    $validator: requiredIf(prop),\n    $message: 'The value is required',\n    $params: {\n      type: 'requiredIf',\n      prop: prop\n    }\n  };\n}\n\nvar validate$1 = function validate(prop, val) {\n  return !prop ? req(val) : true;\n};\n/**\n * Returns required if the passed property is falsy.\n * @param {Boolean | String | function(any): Boolean | Ref<string | boolean>} propOrFunction\n * @return {function(value: *, parentVM: object): Boolean}\n */\n\n\nfunction requiredUnless(propOrFunction) {\n  return function (value, parentVM) {\n    if (typeof propOrFunction !== 'function') {\n      return validate$1(Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(propOrFunction), value);\n    }\n\n    var result = propOrFunction.call(this, value, parentVM);\n    return validate$1(result, value);\n  };\n}\n\n/**\n * Returns required unless the passed property is truthy\n * @param {Boolean | String | function(): (Boolean | Promise<boolean>)} prop\n * @return {NormalizedValidator}\n */\n\nfunction requiredUnless$1 (prop) {\n  return {\n    $validator: requiredUnless(prop),\n    $message: 'The value is required',\n    $params: {\n      type: 'requiredUnless',\n      prop: prop\n    }\n  };\n}\n\n/**\n * Check if two values are identical.\n * @param {*} equalTo\n * @return {function(*=): boolean}\n */\n\nfunction sameAs (equalTo) {\n  return function (value) {\n    return Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(value) === Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(equalTo);\n  };\n}\n\n/**\n * Check if two values are identical\n * @param {*} equalTo\n * @param {String} [otherName]\n * @return {NormalizedValidator}\n */\n\nfunction sameAs$1 (equalTo) {\n  var otherName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'other';\n  return {\n    $validator: sameAs(equalTo),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The value must be equal to the \".concat(otherName, \" value\");\n    },\n    $params: {\n      equalTo: equalTo,\n      otherName: otherName,\n      type: 'sameAs'\n    }\n  };\n}\n\nvar urlRegex = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i;\nvar url = regex(urlRegex);\n\n/**\n * Check if a value is a url\n * @type {NormalizedValidator}\n */\n\nvar url$1 = {\n  $validator: url,\n  $message: 'The value is not a valid URL address',\n  $params: {\n    type: 'url'\n  }\n};\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction syncOr(validators) {\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return validators.reduce(function (valid, fn) {\n      if (unwrapValidatorResponse(valid)) return valid;\n      return unwrapNormalizedValidator(fn).apply(_this, args);\n    }, false);\n  };\n}\n\nfunction asyncOr(validators) {\n  return function () {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return validators.reduce(function (valid, fn) {\n      return _await(valid, function (r) {\n        return unwrapValidatorResponse(r) ? r : unwrapNormalizedValidator(fn).apply(_this2, args);\n      });\n    }, Promise.resolve(false));\n  };\n}\n/**\n * Returns true when one of the provided functions returns true.\n * @param {...(NormalizedValidator|Function)} validators\n * @return {{$validator: function(...[*]=): (boolean | Promise<boolean>), $async: boolean, $watchTargets: any[]}}\n */\n\n\nfunction or() {\n  for (var _len3 = arguments.length, validators = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    validators[_key3] = arguments[_key3];\n  }\n\n  var $async = validators.some(function (v) {\n    return v.$async;\n  });\n  var $watchTargets = validators.reduce(function (all, v) {\n    if (!v.$watchTargets) return all;\n    return all.concat(v.$watchTargets);\n  }, []);\n\n  var $validator = function $validator() {\n    return false;\n  };\n\n  if (validators.length) $validator = $async ? asyncOr(validators) : syncOr(validators);\n  return {\n    $async: $async,\n    $validator: $validator,\n    $watchTargets: $watchTargets\n  };\n}\n\n/**\n * Returns true when one of the provided functions returns true.\n * @param {...(NormalizedValidator|Function)} validators\n * @return {NormalizedValidator}\n */\n\nfunction or$1 () {\n  return withParams({\n    type: 'or'\n  }, withMessage('The value does not match any of the provided validators', or.apply(void 0, arguments)));\n}\n\nfunction _await$1(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n/**\n *\n * @param validators\n * @return {function(...[*]=): Promise<boolean>}\n */\n\n\nfunction syncAnd(validators) {\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return validators.reduce(function (valid, fn) {\n      if (!unwrapValidatorResponse(valid)) return valid;\n      return unwrapNormalizedValidator(fn).apply(_this, args);\n    }, true);\n  };\n}\n\nfunction asyncAnd(validators) {\n  return function () {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return validators.reduce(function (valid, fn) {\n      return _await$1(valid, function (r) {\n        return unwrapValidatorResponse(r) ? unwrapNormalizedValidator(fn).apply(_this2, args) : r;\n      });\n    }, Promise.resolve(true));\n  };\n}\n/**\n * Returns true when all validators are truthy\n * @param {...(NormalizedValidator | Function)} validators\n * @return {{$validator: function(...[*]=): (boolean | Promise<boolean>), $async: boolean, $watchTargets: any[]}}\n */\n\n\nfunction and() {\n  for (var _len3 = arguments.length, validators = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    validators[_key3] = arguments[_key3];\n  }\n\n  var $async = validators.some(function (v) {\n    return v.$async;\n  });\n  var $watchTargets = validators.reduce(function (all, v) {\n    if (!v.$watchTargets) return all;\n    return all.concat(v.$watchTargets);\n  }, []);\n\n  var $validator = function $validator() {\n    return false;\n  };\n\n  if (validators.length) $validator = $async ? asyncAnd(validators) : syncAnd(validators);\n  return {\n    $async: $async,\n    $validator: $validator,\n    $watchTargets: $watchTargets\n  };\n}\n\n/**\n * Validate if all validators match.\n * @param {...*} validators\n * @returns {NormalizedValidator}\n */\n\nfunction and$1 () {\n  return withParams({\n    type: 'and'\n  }, withMessage('The value does not match all of the provided validators', and.apply(void 0, arguments)));\n}\n\n/**\n * Swaps the result of a value\n * @param {NormalizedValidator|Function} validator\n * @returns {function(*=, *=): boolean}\n */\n\nfunction not (validator) {\n  return function (value, vm) {\n    if (!req(value)) return true;\n    var response = unwrapNormalizedValidator(validator).call(this, value, vm);\n    if (!isPromise(response)) return !unwrapValidatorResponse(response);\n    return response.then(function (r) {\n      return !unwrapValidatorResponse(r);\n    });\n  };\n}\n\n/**\n * Swaps the result of a value\n * @param {NormalizedValidator|Function} validator\n * @returns {NormalizedValidator}\n */\n\nfunction not$1 (validator) {\n  return {\n    $validator: not(validator),\n    $message: \"The value does not match the provided validator\",\n    $params: {\n      type: 'not'\n    }\n  };\n}\n\n/**\n * Check if a value is above a threshold.\n * @param {String | Number | Ref<Number> | Ref<String>} min\n * @returns {function(*=): boolean}\n */\n\nfunction minValue (min) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +value >= +Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(min);\n  };\n}\n\n/**\n * Check if a value is above a threshold.\n * @param {String | Number | Ref<Number> | Ref<String>} min\n * @returns {NormalizedValidator}\n */\n\nfunction minValue$1 (min) {\n  return {\n    $validator: minValue(min),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The minimum value allowed is \".concat($params.min);\n    },\n    $params: {\n      min: min,\n      type: 'minValue'\n    }\n  };\n}\n\n/**\n * Check if value is below a threshold.\n * @param {Number | Ref<Number> | Ref<String>} max\n * @returns {function(*=): boolean}\n */\n\nfunction maxValue (max) {\n  return function (value) {\n    return !req(value) || (!/\\s/.test(value) || value instanceof Date) && +value <= +Object(vue_demi__WEBPACK_IMPORTED_MODULE_0__[\"unref\"])(max);\n  };\n}\n\n/**\n * Check if value is below a threshold.\n * @param {Number | Ref<Number> | Ref<String>} max\n * @return {NormalizedValidator}\n */\n\nvar maxValue$1 = (function (max) {\n  return {\n    $validator: maxValue(max),\n    $message: function $message(_ref) {\n      var $params = _ref.$params;\n      return \"The maximum value is \".concat($params.max);\n    },\n    $params: {\n      max: max,\n      type: 'maxValue'\n    }\n  };\n});\n\n// ^-[0-9]+$ - only for negative integer (minus sign without at least 1 digit is not a number)\n\nvar integer = regex(/(^[0-9]*$)|(^-[0-9]+$)/);\n\n/**\n * Validate if value is integer.\n * @type {NormalizedValidator}\n */\n\nvar integer$1 = {\n  $validator: integer,\n  $message: 'Value is not an integer',\n  $params: {\n    type: 'integer'\n  }\n};\n\nvar decimal = regex(/^[-]?\\d*(\\.\\d+)?$/);\n\n/**\n * Validate if value is decimal number.\n * @type {NormalizedValidator}\n */\n\nvar decimal$1 = {\n  $validator: decimal,\n  $message: 'Value must be decimal',\n  $params: {\n    type: 'decimal'\n  }\n};\n\n/**\n * Creates a translatable version of `withMessage` helper.\n * @param {function} t - the translation function of your choice\n * @param {function} [messagePath] - a function to generate the message path, passed to `t` for each message. By default it is `validations.${$validator}`\n * @param {function} [messageParams] - a function to augment the params, passed to `t` for each message.\n */\n\nfunction createI18nMessage(_ref) {\n  var t = _ref.t,\n      _ref$messagePath = _ref.messagePath,\n      messagePath = _ref$messagePath === void 0 ? function (_ref2) {\n    var $validator = _ref2.$validator;\n    return \"validations.\".concat($validator);\n  } : _ref$messagePath,\n      _ref$messageParams = _ref.messageParams,\n      messageParams = _ref$messageParams === void 0 ? function (params) {\n    return params;\n  } : _ref$messageParams;\n  return function withI18nMessage(validator) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref3$withArguments = _ref3.withArguments,\n        withArguments = _ref3$withArguments === void 0 ? false : _ref3$withArguments,\n        _ref3$messagePath = _ref3.messagePath,\n        localMessagePath = _ref3$messagePath === void 0 ? messagePath : _ref3$messagePath,\n        _ref3$messageParams = _ref3.messageParams,\n        localMessageParams = _ref3$messageParams === void 0 ? messageParams : _ref3$messageParams;\n\n    function message(props) {\n      return t(localMessagePath(props), localMessageParams(Object.assign({\n        model: props.$model,\n        property: props.$property,\n        pending: props.$pending,\n        invalid: props.$invalid,\n        response: props.$response,\n        validator: props.$validator,\n        propertyPath: props.$propertyPath\n      }, props.$params)));\n    }\n\n    if (withArguments && typeof validator === 'function') {\n      return function () {\n        return withMessage(message, validator.apply(void 0, arguments));\n      };\n    }\n\n    return withMessage(message, validator);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZWxpZGF0ZS92YWxpZGF0b3JzL2Rpc3QvaW5kZXguZXNtLmpzP2UzZTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBaUM7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QywrQkFBK0I7QUFDNUU7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTOztBQUVqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtCQUErQjtBQUMxQyxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyw2QkFBNkI7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QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVMsMEhBQTBILFdBQVc7QUFDekosV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZ2dCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B2dWVsaWRhdGUvdmFsaWRhdG9ycy9kaXN0L2luZGV4LmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVucmVmIH0gZnJvbSAndnVlLWRlbWknO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIG8gIT09IG51bGwgJiYgX3R5cGVvZihvKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdGFuZGFyZCBWYWxpZGF0b3JPYmplY3RcbiAqIFdyYXBzIGEgcGxhaW4gZnVuY3Rpb24gaW50byBhIFZhbGlkYXRvck9iamVjdFxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSB2YWxpZGF0b3JcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KHZhbGlkYXRvcikge1xuICByZXR1cm4gaXNGdW5jdGlvbih2YWxpZGF0b3IuJHZhbGlkYXRvcikgPyBPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0b3IpIDoge1xuICAgICR2YWxpZGF0b3I6IHZhbGlkYXRvclxuICB9O1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICByZXR1cm4gaXNPYmplY3Qob2JqZWN0KSAmJiBpc0Z1bmN0aW9uKG9iamVjdC50aGVuKTtcbn1cbi8qKlxuICogVW53cmFwcyBhIFZhbGlkYXRvclJlc3BvbnNlIG9iamVjdCwgaW50byBhIGJvb2xlYW4uXG4gKiBAcGFyYW0ge1ZhbGlkYXRvclJlc3BvbnNlfSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gdW53cmFwVmFsaWRhdG9yUmVzcG9uc2UocmVzdWx0KSB7XG4gIGlmIChfdHlwZW9mKHJlc3VsdCkgPT09ICdvYmplY3QnKSByZXR1cm4gcmVzdWx0LiR2YWxpZDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVW53cmFwcyBhIGBOb3JtYWxpemVkVmFsaWRhdG9yYCBvYmplY3QsIHJldHVybmluZyBpdHMgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yIHwgRnVuY3Rpb259IHZhbGlkYXRvclxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIHZhbGlkYXRvci4kdmFsaWRhdG9yIHx8IHZhbGlkYXRvcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgYXR0YWNoaW5nIHBhcmFtZXRlcnMgdG8gYSB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSAkcGFyYW1zXG4gKiBAcGFyYW0ge05vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb259ICR2YWxpZGF0b3JcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gd2l0aFBhcmFtcygkcGFyYW1zLCAkdmFsaWRhdG9yKSB7XG4gIGlmICghaXNPYmplY3QoJHBhcmFtcykpIHRocm93IG5ldyBFcnJvcihcIltAdnVlbGlkYXRlL3ZhbGlkYXRvcnNdOiBGaXJzdCBwYXJhbWV0ZXIgdG8gXFxcIndpdGhQYXJhbXNcXFwiIHNob3VsZCBiZSBhbiBvYmplY3QsIHByb3ZpZGVkIFwiLmNvbmNhdChfdHlwZW9mKCRwYXJhbXMpKSk7XG4gIGlmICghaXNPYmplY3QoJHZhbGlkYXRvcikgJiYgIWlzRnVuY3Rpb24oJHZhbGlkYXRvcikpIHRocm93IG5ldyBFcnJvcihcIltAdnVlbGlkYXRlL3ZhbGlkYXRvcnNdOiBWYWxpZGF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG9iamVjdCB3aXRoICR2YWxpZGF0b3IgcGFyYW1ldGVyXCIpO1xuICB2YXIgdmFsaWRhdG9yT2JqID0gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KCR2YWxpZGF0b3IpO1xuICB2YWxpZGF0b3JPYmouJHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRvck9iai4kcGFyYW1zIHx8IHt9LCAkcGFyYW1zKTtcbiAgcmV0dXJuIHZhbGlkYXRvck9iajtcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWVzc2FnZUNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gKiBAcmV0dXJuIFN0cmluZ1xuICovXG5cbi8qKlxuICogQXR0YWNoZXMgYSBtZXNzYWdlIHRvIGEgdmFsaWRhdG9yXG4gKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFjayB8IFN0cmluZ30gJG1lc3NhZ2VcbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbn0gJHZhbGlkYXRvclxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiB3aXRoTWVzc2FnZSgkbWVzc2FnZSwgJHZhbGlkYXRvcikge1xuICBpZiAoIWlzRnVuY3Rpb24oJG1lc3NhZ2UpICYmIHR5cGVvZiB1bnJlZigkbWVzc2FnZSkgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoXCJbQHZ1ZWxpZGF0ZS92YWxpZGF0b3JzXTogRmlyc3QgcGFyYW1ldGVyIHRvIFxcXCJ3aXRoTWVzc2FnZVxcXCIgc2hvdWxkIGJlIHN0cmluZyBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZywgcHJvdmlkZWQgXCIuY29uY2F0KF90eXBlb2YoJG1lc3NhZ2UpKSk7XG4gIGlmICghaXNPYmplY3QoJHZhbGlkYXRvcikgJiYgIWlzRnVuY3Rpb24oJHZhbGlkYXRvcikpIHRocm93IG5ldyBFcnJvcihcIltAdnVlbGlkYXRlL3ZhbGlkYXRvcnNdOiBWYWxpZGF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG9iamVjdCB3aXRoICR2YWxpZGF0b3IgcGFyYW1ldGVyXCIpO1xuICB2YXIgdmFsaWRhdG9yT2JqID0gbm9ybWFsaXplVmFsaWRhdG9yT2JqZWN0KCR2YWxpZGF0b3IpO1xuICB2YWxpZGF0b3JPYmouJG1lc3NhZ2UgPSAkbWVzc2FnZTtcbiAgcmV0dXJuIHZhbGlkYXRvck9iajtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oKik6IFByb21pc2U8Ym9vbGVhbnxWYWxpZGF0b3JSZXNwb25zZT59IGFzeW5jVmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVmPCo+W118ZnVuY3Rpb24oKik6ICp9IHdhdGNoVGFyZ2V0c1xuICovXG5cbi8qKlxuICogV3JhcHMgdmFsaWRhdG9ycyB0aGF0IHJldHVybnMgYSBQcm9taXNlLlxuICogQHBhcmFtIHthc3luY1ZhbGlkYXRvcn0gJHZhbGlkYXRvclxuICogQHBhcmFtIHt3YXRjaFRhcmdldHN9ICR3YXRjaFRhcmdldHNcbiAqIEByZXR1cm4ge3skYXN5bmM6IGJvb2xlYW4sICR2YWxpZGF0b3I6IGFzeW5jVmFsaWRhdG9yLCAkd2F0Y2hUYXJnZXRzOiB3YXRjaFRhcmdldHN9fVxuICovXG5cbmZ1bmN0aW9uIHdpdGhBc3luYygkdmFsaWRhdG9yKSB7XG4gIHZhciAkd2F0Y2hUYXJnZXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgdmFyIHZhbGlkYXRvck9iaiA9IG5vcm1hbGl6ZVZhbGlkYXRvck9iamVjdCgkdmFsaWRhdG9yKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRvck9iaiwge1xuICAgICRhc3luYzogdHJ1ZSxcbiAgICAkd2F0Y2hUYXJnZXRzOiAkd2F0Y2hUYXJnZXRzXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHZhbGlkYXRvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBmdW5jdGlvbiAkdmFsaWRhdG9yKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvdGhlcnMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBvdGhlcnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBnbyBvdmVyIHRoZSBjb2xsZWN0aW9uLiBJdCBjYW4gYmUgYSByZWYgYXMgd2VsbC5cbiAgICAgIHJldHVybiB1bnJlZihjb2xsZWN0aW9uKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBvYmplY3QpIHtcbiAgICAgICAgLy8gZ28gb3ZlciBlYWNoIHByb3BlcnR5XG4gICAgICAgIHZhciBjb2xsZWN0aW9uRW50cnlSZXN1bHQgPSBPYmplY3QuZW50cmllcyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbiAoYWxsLCBfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICAgIGtleSA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgICAkbW9kZWwgPSBfcmVmMlsxXTtcblxuICAgICAgICAgIC8vIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICAgIHZhciBpbm5lclZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzW2tleV07IC8vIGdvIG92ZXIgZWFjaCB2YWxpZGF0b3IgYW5kIHJ1biBpdFxuXG4gICAgICAgICAgdmFyIHByb3BlcnR5UmVzdWx0ID0gT2JqZWN0LmVudHJpZXMoaW5uZXJWYWxpZGF0b3JzKS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3JOYW1lID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbGlkYXRvciA9IF9yZWY0WzFdO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IHRoZSB2YWxpZGF0b3IuIFN1cHBvcnRzIHNpbXBsZSBhbmQgZXh0ZW5kZWQgdmFsaWRhdG9ycy5cbiAgICAgICAgICAgIHZhciB2YWxpZGF0b3JGdW5jdGlvbiA9IHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoY3VycmVudFZhbGlkYXRvcik7IC8vIENhbGwgdGhlIHZhbGlkYXRvciB3aXRoIGNvcnJlY3QgcGFyYW1ldGVyc1xuXG4gICAgICAgICAgICB2YXIgJHJlc3BvbnNlID0gdmFsaWRhdG9yRnVuY3Rpb24uY2FsbC5hcHBseSh2YWxpZGF0b3JGdW5jdGlvbiwgW190aGlzLCAkbW9kZWxdLmNvbmNhdChvdGhlcnMpKTsgLy8gZXh0cmFjdCB0aGUgdmFsaWQgZnJvbSB0aGUgcmVzdWx0XG5cbiAgICAgICAgICAgIHZhciAkdmFsaWQgPSB1bndyYXBWYWxpZGF0b3JSZXNwb25zZSgkcmVzcG9uc2UpOyAvLyBzdG9yZSB0aGUgZW50aXJlIHJlc3BvbnNlIGZvciBsYXRlclxuXG4gICAgICAgICAgICBhbGwuJGRhdGFbdmFsaWRhdG9yTmFtZV0gPSAkcmVzcG9uc2U7IC8vIGlmIG5vdCB2YWxpZCwgZ2V0IHRoZSAkbWVzc2FnZVxuXG4gICAgICAgICAgICBpZiAoISR2YWxpZCkge1xuICAgICAgICAgICAgICB2YXIgJG1lc3NhZ2UgPSBjdXJyZW50VmFsaWRhdG9yLiRtZXNzYWdlIHx8ICcnO1xuICAgICAgICAgICAgICB2YXIgJHBhcmFtcyA9IGN1cnJlbnRWYWxpZGF0b3IuJHBhcmFtcyB8fCB7fTsgLy8gSWYgJG1lc3NhZ2UgaXMgYSBmdW5jdGlvbiwgd2UgY2FsbCBpdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBwYXJhbWV0ZXJzXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiAkbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICRtZXNzYWdlID0gJG1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgJHBlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgJGludmFsaWQ6ICEkdmFsaWQsXG4gICAgICAgICAgICAgICAgICAkcGFyYW1zOiAkcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgJG1vZGVsOiAkbW9kZWwsXG4gICAgICAgICAgICAgICAgICAkcmVzcG9uc2U6ICRyZXNwb25zZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IC8vIHNhdmUgdGhlIGVycm9yIG9iamVjdFxuXG5cbiAgICAgICAgICAgICAgYWxsLiRlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgJHByb3BlcnR5OiBrZXksXG4gICAgICAgICAgICAgICAgJG1lc3NhZ2U6ICRtZXNzYWdlLFxuICAgICAgICAgICAgICAgICRwYXJhbXM6ICRwYXJhbXMsXG4gICAgICAgICAgICAgICAgJHJlc3BvbnNlOiAkcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgJG1vZGVsOiAkbW9kZWwsXG4gICAgICAgICAgICAgICAgJHBlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICR2YWxpZGF0b3I6IHZhbGlkYXRvck5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICR2YWxpZDogYWxsLiR2YWxpZCAmJiAkdmFsaWQsXG4gICAgICAgICAgICAgICRkYXRhOiBhbGwuJGRhdGEsXG4gICAgICAgICAgICAgICRlcnJvcnM6IGFsbC4kZXJyb3JzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICR2YWxpZDogdHJ1ZSxcbiAgICAgICAgICAgICRkYXRhOiB7fSxcbiAgICAgICAgICAgICRlcnJvcnM6IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWxsLiRkYXRhW2tleV0gPSBwcm9wZXJ0eVJlc3VsdC4kZGF0YTtcbiAgICAgICAgICBhbGwuJGVycm9yc1trZXldID0gcHJvcGVydHlSZXN1bHQuJGVycm9ycztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHZhbGlkOiBhbGwuJHZhbGlkICYmIHByb3BlcnR5UmVzdWx0LiR2YWxpZCxcbiAgICAgICAgICAgICRkYXRhOiBhbGwuJGRhdGEsXG4gICAgICAgICAgICAkZXJyb3JzOiBhbGwuJGVycm9yc1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAkdmFsaWQ6IHRydWUsXG4gICAgICAgICAgJGRhdGE6IHt9LFxuICAgICAgICAgICRlcnJvcnM6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICR2YWxpZDogcHJldmlvdXMuJHZhbGlkICYmIGNvbGxlY3Rpb25FbnRyeVJlc3VsdC4kdmFsaWQsXG4gICAgICAgICAgJGRhdGE6IHByZXZpb3VzLiRkYXRhLmNvbmNhdChjb2xsZWN0aW9uRW50cnlSZXN1bHQuJGRhdGEpLFxuICAgICAgICAgICRlcnJvcnM6IHByZXZpb3VzLiRlcnJvcnMuY29uY2F0KGNvbGxlY3Rpb25FbnRyeVJlc3VsdC4kZXJyb3JzKVxuICAgICAgICB9O1xuICAgICAgfSwge1xuICAgICAgICAkdmFsaWQ6IHRydWUsXG4gICAgICAgICRkYXRhOiBbXSxcbiAgICAgICAgJGVycm9yczogW11cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLy8gY29sbGVjdCBhbGwgdGhlIHZhbGlkYXRpb24gZXJyb3JzIGludG8gYSAyIGRpbWVuc2lvbmFsIGFycmF5LCBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgY29sbGVjdGlvbiwgeW91IGhhdmUgYW4gYXJyYXkgb2YgZXJyb3IgbWVzc2FnZXMuXG4gICAgJG1lc3NhZ2U6IGZ1bmN0aW9uICRtZXNzYWdlKF9yZWY1KSB7XG4gICAgICB2YXIgJHJlc3BvbnNlID0gX3JlZjUuJHJlc3BvbnNlO1xuICAgICAgcmV0dXJuICRyZXNwb25zZSA/ICRyZXNwb25zZS4kZXJyb3JzLm1hcChmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhjb250ZXh0KS5tYXAoZnVuY3Rpb24gKGVycm9ycykge1xuICAgICAgICAgIHJldHVybiBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yLiRtZXNzYWdlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgIH0pIDogW107XG4gICAgfVxuICB9O1xufVxuXG52YXIgcmVxID0gZnVuY3Rpb24gcmVxKHZhbHVlKSB7XG4gIHZhbHVlID0gdW5yZWYodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiAhIXZhbHVlLmxlbmd0aDtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBpbnZhbGlkIGRhdGUgd29uJ3QgcGFzc1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGlmIChfdHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBfIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gISFTdHJpbmcodmFsdWUpLmxlbmd0aDtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiBhbiBhcmJpdHJhcnkgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG52YXIgbGVuID0gZnVuY3Rpb24gbGVuKHZhbHVlKSB7XG4gIHZhbHVlID0gdW5yZWYodmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoO1xufTtcbi8qKlxuICogUmVnZXggYmFzZWQgdmFsaWRhdG9yIHRlbXBsYXRlXG4gKiBAcGFyYW0ge1JlZ0V4cH0gZXhwclxuICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4KGV4cHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gdW5yZWYodmFsdWUpO1xuICAgIHJldHVybiAhcmVxKHZhbHVlKSB8fCBleHByLnRlc3QodmFsdWUpO1xuICB9O1xufVxuXG5cblxudmFyIGNvbW1vbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB3aXRoUGFyYW1zOiB3aXRoUGFyYW1zLFxuICB3aXRoTWVzc2FnZTogd2l0aE1lc3NhZ2UsXG4gIHdpdGhBc3luYzogd2l0aEFzeW5jLFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICByZXE6IHJlcSxcbiAgbGVuOiBsZW4sXG4gIHJlZ2V4OiByZWdleCxcbiAgdW53cmFwOiB1bnJlZixcbiAgdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcjogdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcixcbiAgdW53cmFwVmFsaWRhdG9yUmVzcG9uc2U6IHVud3JhcFZhbGlkYXRvclJlc3BvbnNlLFxuICBub3JtYWxpemVWYWxpZGF0b3JPYmplY3Q6IG5vcm1hbGl6ZVZhbGlkYXRvck9iamVjdFxufSk7XG5cbnZhciBhbHBoYSA9IHJlZ2V4KC9eW2EtekEtWl0qJC8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGFscGhhYmV0aWNhbCBzdHJpbmcuXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgYWxwaGEkMSA9IHtcbiAgJHZhbGlkYXRvcjogYWxwaGEsXG4gICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIG5vdCBhbHBoYWJldGljYWwnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ2FscGhhJ1xuICB9XG59O1xuXG52YXIgYWxwaGFOdW0gPSByZWdleCgvXlthLXpBLVowLTldKiQvKTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiB2YWx1ZSBpcyBhbHBoYS1udW1lcmljIHN0cmluZy5cbiAqIEB0eXBlIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbnZhciBhbHBoYU51bSQxID0ge1xuICAkdmFsaWRhdG9yOiBhbHBoYU51bSxcbiAgJG1lc3NhZ2U6ICdUaGUgdmFsdWUgbXVzdCBiZSBhbHBoYS1udW1lcmljJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdhbHBoYU51bSdcbiAgfVxufTtcblxudmFyIG51bWVyaWMgPSByZWdleCgvXlxcZCooXFwuXFxkKyk/JC8pO1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB2YWx1ZSBpcyBudW1lcmljLlxuICogQHR5cGUgTm9ybWFsaXplZFZhbGlkYXRvclxuICovXG5cbnZhciBudW1lcmljJDEgPSB7XG4gICR2YWxpZGF0b3I6IG51bWVyaWMsXG4gICRtZXNzYWdlOiAnVmFsdWUgbXVzdCBiZSBudW1lcmljJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdudW1lcmljJ1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgbnVtZXJpYyB2YWx1ZSBpcyBiZXR3ZWVuIHR3byB2YWx1ZXMuXG4gKiBAcGFyYW0ge1JlZjxOdW1iZXI+IHwgTnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7UmVmPE51bWJlcj4gfCBOdW1iZXJ9IG1heFxuICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiBib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGJldHdlZW4gKG1pbiwgbWF4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gIXJlcSh2YWx1ZSkgfHwgKCEvXFxzLy50ZXN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICt1bnJlZihtaW4pIDw9ICt2YWx1ZSAmJiArdW5yZWYobWF4KSA+PSArdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYmV0d2VlbiB0d28gdmFsdWVzLlxuICogQHBhcmFtIHtSZWY8TnVtYmVyPiB8IE51bWJlcn0gbWluXG4gKiBAcGFyYW0ge1JlZjxOdW1iZXI+IHwgTnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gYmV0d2VlbiQxIChtaW4sIG1heCkge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IGJldHdlZW4obWluLCBtYXgpLFxuICAgICRtZXNzYWdlOiBmdW5jdGlvbiAkbWVzc2FnZShfcmVmKSB7XG4gICAgICB2YXIgJHBhcmFtcyA9IF9yZWYuJHBhcmFtcztcbiAgICAgIHJldHVybiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gXCIuY29uY2F0KCRwYXJhbXMubWluLCBcIiBhbmQgXCIpLmNvbmNhdCgkcGFyYW1zLm1heCk7XG4gICAgfSxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4LFxuICAgICAgdHlwZTogJ2JldHdlZW4nXG4gICAgfVxuICB9O1xufVxuXG52YXIgZW1haWxSZWdleCA9IC9eKD86W0EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLltBLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18W1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldezIsfSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG52YXIgZW1haWwgPSByZWdleChlbWFpbFJlZ2V4KTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiB2YWx1ZSBpcyBhbiBlbWFpbC5cbiAqIEB0eXBlIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbnZhciBlbWFpbCQxID0ge1xuICAkdmFsaWRhdG9yOiBlbWFpbCxcbiAgJG1lc3NhZ2U6ICdWYWx1ZSBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdlbWFpbCdcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyBhbiBJUCBBZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlwQWRkcmVzcyAodmFsdWUpIHtcbiAgaWYgKCFyZXEodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuaWJibGVzID0gdmFsdWUuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIG5pYmJsZXMubGVuZ3RoID09PSA0ICYmIG5pYmJsZXMuZXZlcnkobmliYmxlVmFsaWQpO1xufVxuXG52YXIgbmliYmxlVmFsaWQgPSBmdW5jdGlvbiBuaWJibGVWYWxpZChuaWJibGUpIHtcbiAgaWYgKG5pYmJsZS5sZW5ndGggPiAzIHx8IG5pYmJsZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmliYmxlWzBdID09PSAnMCcgJiYgbmliYmxlICE9PSAnMCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIW5pYmJsZS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbnVtZXJpYyA9ICtuaWJibGUgfCAwO1xuICByZXR1cm4gbnVtZXJpYyA+PSAwICYmIG51bWVyaWMgPD0gMjU1O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBpZiB2YWx1ZSBpcyBhbiBpcEFkZHJlc3Mgc3RyaW5nLlxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIGlwQWRkcmVzcyQxID0ge1xuICAkdmFsaWRhdG9yOiBpcEFkZHJlc3MsXG4gICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIElQIGFkZHJlc3MnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ2lwQWRkcmVzcydcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIHByb3Blcmx5IGZvcm1hdHRlZCBNYWMgQWRkcmVzcy5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgUmVmPFN0cmluZz59IFtzZXBhcmF0b3JdXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKik6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbWFjQWRkcmVzcyAoKSB7XG4gIHZhciBzZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICc6JztcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHNlcGFyYXRvciA9IHVucmVmKHNlcGFyYXRvcik7XG5cbiAgICBpZiAoIXJlcSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRzID0gdHlwZW9mIHNlcGFyYXRvciA9PT0gJ3N0cmluZycgJiYgc2VwYXJhdG9yICE9PSAnJyA/IHZhbHVlLnNwbGl0KHNlcGFyYXRvcikgOiB2YWx1ZS5sZW5ndGggPT09IDEyIHx8IHZhbHVlLmxlbmd0aCA9PT0gMTYgPyB2YWx1ZS5tYXRjaCgvLnsyfS9nKSA6IG51bGw7XG4gICAgcmV0dXJuIHBhcnRzICE9PSBudWxsICYmIChwYXJ0cy5sZW5ndGggPT09IDYgfHwgcGFydHMubGVuZ3RoID09PSA4KSAmJiBwYXJ0cy5ldmVyeShoZXhWYWxpZCk7XG4gIH07XG59XG5cbnZhciBoZXhWYWxpZCA9IGZ1bmN0aW9uIGhleFZhbGlkKGhleCkge1xuICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCkubWF0Y2goL15bMC05YS1mXXsyfSQvKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgaWYgdmFsdWUgaXMgYSB2YWxpZCBNYWMgQWRkcmVzcyBzdHJpbmcuXG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBtYWNBZGRyZXNzJDEgKHNlcGFyYXRvcikge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IG1hY0FkZHJlc3Moc2VwYXJhdG9yKSxcbiAgICAkbWVzc2FnZTogJ1RoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBNQUMgQWRkcmVzcycsXG4gICAgJHBhcmFtczoge1xuICAgICAgdHlwZTogJ21hY0FkZHJlc3MnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHByb3ZpZGVkIHZhbHVlIGhhcyBhIG1heGltdW0gbGVuZ3RoXG4gKiBAcGFyYW0ge051bWJlciB8IFJlZjxOdW1iZXI+fSBsZW5ndGhcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihBcnJheXxPYmplY3R8U3RyaW5nKTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBtYXhMZW5ndGggKGxlbmd0aCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICFyZXEodmFsdWUpIHx8IGxlbih2YWx1ZSkgPD0gdW5yZWYobGVuZ3RoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgbWF4IGxlbmd0aCBvZiBhIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxuZnVuY3Rpb24gbWF4TGVuZ3RoJDEgKG1heCkge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IG1heExlbmd0aChtYXgpLFxuICAgICRtZXNzYWdlOiBmdW5jdGlvbiAkbWVzc2FnZShfcmVmKSB7XG4gICAgICB2YXIgJHBhcmFtcyA9IF9yZWYuJHBhcmFtcztcbiAgICAgIHJldHVybiBcIlRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGlzIFwiLmNvbmNhdCgkcGFyYW1zLm1heCk7XG4gICAgfSxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtYXg6IG1heCxcbiAgICAgIHR5cGU6ICdtYXhMZW5ndGgnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICogQHBhcmFtIHtOdW1iZXIgfCBSZWY8TnVtYmVyPn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oQXJyYXl8T2JqZWN0fFN0cmluZyk6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbWluTGVuZ3RoIChsZW5ndGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhcmVxKHZhbHVlKSB8fCBsZW4odmFsdWUpID49IHVucmVmKGxlbmd0aCk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge051bWJlciB8IFJlZjxOdW1iZXI+fSBtaW5cbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG1pbkxlbmd0aCQxIChtaW4pIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBtaW5MZW5ndGgobWluKSxcbiAgICAkbWVzc2FnZTogZnVuY3Rpb24gJG1lc3NhZ2UoX3JlZikge1xuICAgICAgdmFyICRwYXJhbXMgPSBfcmVmLiRwYXJhbXM7XG4gICAgICByZXR1cm4gXCJUaGlzIGZpZWxkIHNob3VsZCBiZSBhdCBsZWFzdCBcIi5jb25jYXQoJHBhcmFtcy5taW4sIFwiIGxvbmdcIik7XG4gICAgfSxcbiAgICAkcGFyYW1zOiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIHR5cGU6ICdtaW5MZW5ndGgnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIHZhbHVlIGlzIGVtcHR5LlxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheSB8IERhdGUgfCBPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiByZXF1aXJlZCAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiByZXEodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgZW1wdHkgb3Igbm90LlxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIHJlcXVpcmVkJDEgPSB7XG4gICR2YWxpZGF0b3I6IHJlcXVpcmVkLFxuICAkbWVzc2FnZTogJ1ZhbHVlIGlzIHJlcXVpcmVkJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdyZXF1aXJlZCdcbiAgfVxufTtcblxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocHJvcCwgdmFsKSB7XG4gIHJldHVybiBwcm9wID8gcmVxKHZhbCkgOiB0cnVlO1xufTtcbi8qKlxuICogUmV0dXJucyByZXF1aXJlZCBpZiB0aGUgcGFzc2VkIHByb3BlcnR5IGlzIHRydXRoeVxuICogQHBhcmFtIHtCb29sZWFuIHwgU3RyaW5nIHwgZnVuY3Rpb24oYW55KTogQm9vbGVhbiB8IFJlZjxzdHJpbmcgfCBib29sZWFuPn0gcHJvcE9yRnVuY3Rpb25cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKHZhbHVlOiAqLCBwYXJlbnRWTTogb2JqZWN0KTogQm9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlcXVpcmVkSWYocHJvcE9yRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyZW50Vk0pIHtcbiAgICBpZiAodHlwZW9mIHByb3BPckZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUodW5yZWYocHJvcE9yRnVuY3Rpb24pLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHByb3BPckZ1bmN0aW9uLmNhbGwodGhpcywgdmFsdWUsIHBhcmVudFZNKTtcbiAgICByZXR1cm4gdmFsaWRhdGUocmVzdWx0LCB2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyByZXF1aXJlZCBpZiB0aGUgcGFzc2VkIHByb3BlcnR5IGlzIHRydXRoeVxuICogQHBhcmFtIHtCb29sZWFuIHwgU3RyaW5nIHwgZnVuY3Rpb24oKTogKEJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+KX0gcHJvcFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiByZXF1aXJlZElmJDEgKHByb3ApIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiByZXF1aXJlZElmKHByb3ApLFxuICAgICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIHJlcXVpcmVkJyxcbiAgICAkcGFyYW1zOiB7XG4gICAgICB0eXBlOiAncmVxdWlyZWRJZicsXG4gICAgICBwcm9wOiBwcm9wXG4gICAgfVxuICB9O1xufVxuXG52YXIgdmFsaWRhdGUkMSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHByb3AsIHZhbCkge1xuICByZXR1cm4gIXByb3AgPyByZXEodmFsKSA6IHRydWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHJlcXVpcmVkIGlmIHRoZSBwYXNzZWQgcHJvcGVydHkgaXMgZmFsc3kuXG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBTdHJpbmcgfCBmdW5jdGlvbihhbnkpOiBCb29sZWFuIHwgUmVmPHN0cmluZyB8IGJvb2xlYW4+fSBwcm9wT3JGdW5jdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb24odmFsdWU6ICosIHBhcmVudFZNOiBvYmplY3QpOiBCb29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gcmVxdWlyZWRVbmxlc3MocHJvcE9yRnVuY3Rpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgcGFyZW50Vk0pIHtcbiAgICBpZiAodHlwZW9mIHByb3BPckZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUkMSh1bnJlZihwcm9wT3JGdW5jdGlvbiksIHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gcHJvcE9yRnVuY3Rpb24uY2FsbCh0aGlzLCB2YWx1ZSwgcGFyZW50Vk0pO1xuICAgIHJldHVybiB2YWxpZGF0ZSQxKHJlc3VsdCwgdmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgcmVxdWlyZWQgdW5sZXNzIHRoZSBwYXNzZWQgcHJvcGVydHkgaXMgdHJ1dGh5XG4gKiBAcGFyYW0ge0Jvb2xlYW4gfCBTdHJpbmcgfCBmdW5jdGlvbigpOiAoQm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4pfSBwcm9wXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIHJlcXVpcmVkVW5sZXNzJDEgKHByb3ApIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiByZXF1aXJlZFVubGVzcyhwcm9wKSxcbiAgICAkbWVzc2FnZTogJ1RoZSB2YWx1ZSBpcyByZXF1aXJlZCcsXG4gICAgJHBhcmFtczoge1xuICAgICAgdHlwZTogJ3JlcXVpcmVkVW5sZXNzJyxcbiAgICAgIHByb3A6IHByb3BcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICogQHBhcmFtIHsqfSBlcXVhbFRvXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqPSk6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gc2FtZUFzIChlcXVhbFRvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdW5yZWYodmFsdWUpID09PSB1bnJlZihlcXVhbFRvKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBpZGVudGljYWxcbiAqIEBwYXJhbSB7Kn0gZXF1YWxUb1xuICogQHBhcmFtIHtTdHJpbmd9IFtvdGhlck5hbWVdXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIHNhbWVBcyQxIChlcXVhbFRvKSB7XG4gIHZhciBvdGhlck5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdvdGhlcic7XG4gIHJldHVybiB7XG4gICAgJHZhbGlkYXRvcjogc2FtZUFzKGVxdWFsVG8pLFxuICAgICRtZXNzYWdlOiBmdW5jdGlvbiAkbWVzc2FnZShfcmVmKSB7XG4gICAgICB2YXIgJHBhcmFtcyA9IF9yZWYuJHBhcmFtcztcbiAgICAgIHJldHVybiBcIlRoZSB2YWx1ZSBtdXN0IGJlIGVxdWFsIHRvIHRoZSBcIi5jb25jYXQob3RoZXJOYW1lLCBcIiB2YWx1ZVwiKTtcbiAgICB9LFxuICAgICRwYXJhbXM6IHtcbiAgICAgIGVxdWFsVG86IGVxdWFsVG8sXG4gICAgICBvdGhlck5hbWU6IG90aGVyTmFtZSxcbiAgICAgIHR5cGU6ICdzYW1lQXMnXG4gICAgfVxuICB9O1xufVxuXG52YXIgdXJsUmVnZXggPSAvXig/Oig/Omh0dHBzP3xmdHApOlxcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0tKikqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSg/OlxcLig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldLSopKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykqKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpbLz8jXVxcUyopPyQvaTtcbnZhciB1cmwgPSByZWdleCh1cmxSZWdleCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHVybFxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIHVybCQxID0ge1xuICAkdmFsaWRhdG9yOiB1cmwsXG4gICRtZXNzYWdlOiAnVGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIFVSTCBhZGRyZXNzJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICd1cmwnXG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9hd2FpdCh2YWx1ZSwgdGhlbiwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICByZXR1cm4gdGhlbiA/IHRoZW4odmFsdWUpIDogdmFsdWU7XG4gIH1cblxuICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS50aGVuKSB7XG4gICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoZW4gPyB2YWx1ZS50aGVuKHRoZW4pIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHN5bmNPcih2YWxpZGF0b3JzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdG9ycy5yZWR1Y2UoZnVuY3Rpb24gKHZhbGlkLCBmbikge1xuICAgICAgaWYgKHVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHZhbGlkKSkgcmV0dXJuIHZhbGlkO1xuICAgICAgcmV0dXJuIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoZm4pLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICB9LCBmYWxzZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFzeW5jT3IodmFsaWRhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvcnMucmVkdWNlKGZ1bmN0aW9uICh2YWxpZCwgZm4pIHtcbiAgICAgIHJldHVybiBfYXdhaXQodmFsaWQsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiB1bndyYXBWYWxpZGF0b3JSZXNwb25zZShyKSA/IHIgOiB1bndyYXBOb3JtYWxpemVkVmFsaWRhdG9yKGZuKS5hcHBseShfdGhpczIsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSwgUHJvbWlzZS5yZXNvbHZlKGZhbHNlKSk7XG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Li4uKE5vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb24pfSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJuIHt7JHZhbGlkYXRvcjogZnVuY3Rpb24oLi4uWypdPSk6IChib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPiksICRhc3luYzogYm9vbGVhbiwgJHdhdGNoVGFyZ2V0czogYW55W119fVxuICovXG5cblxuZnVuY3Rpb24gb3IoKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsaWRhdG9ycyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgIHZhbGlkYXRvcnNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHZhciAkYXN5bmMgPSB2YWxpZGF0b3JzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdi4kYXN5bmM7XG4gIH0pO1xuICB2YXIgJHdhdGNoVGFyZ2V0cyA9IHZhbGlkYXRvcnMucmVkdWNlKGZ1bmN0aW9uIChhbGwsIHYpIHtcbiAgICBpZiAoIXYuJHdhdGNoVGFyZ2V0cykgcmV0dXJuIGFsbDtcbiAgICByZXR1cm4gYWxsLmNvbmNhdCh2LiR3YXRjaFRhcmdldHMpO1xuICB9LCBbXSk7XG5cbiAgdmFyICR2YWxpZGF0b3IgPSBmdW5jdGlvbiAkdmFsaWRhdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBpZiAodmFsaWRhdG9ycy5sZW5ndGgpICR2YWxpZGF0b3IgPSAkYXN5bmMgPyBhc3luY09yKHZhbGlkYXRvcnMpIDogc3luY09yKHZhbGlkYXRvcnMpO1xuICByZXR1cm4ge1xuICAgICRhc3luYzogJGFzeW5jLFxuICAgICR2YWxpZGF0b3I6ICR2YWxpZGF0b3IsXG4gICAgJHdhdGNoVGFyZ2V0czogJHdhdGNoVGFyZ2V0c1xuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIHJldHVybnMgdHJ1ZS5cbiAqIEBwYXJhbSB7Li4uKE5vcm1hbGl6ZWRWYWxpZGF0b3J8RnVuY3Rpb24pfSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJuIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG9yJDEgKCkge1xuICByZXR1cm4gd2l0aFBhcmFtcyh7XG4gICAgdHlwZTogJ29yJ1xuICB9LCB3aXRoTWVzc2FnZSgnVGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgcHJvdmlkZWQgdmFsaWRhdG9ycycsIG9yLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSkpO1xufVxuXG5mdW5jdGlvbiBfYXdhaXQkMSh2YWx1ZSwgdGhlbiwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICByZXR1cm4gdGhlbiA/IHRoZW4odmFsdWUpIDogdmFsdWU7XG4gIH1cblxuICBpZiAoIXZhbHVlIHx8ICF2YWx1ZS50aGVuKSB7XG4gICAgdmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoZW4gPyB2YWx1ZS50aGVuKHRoZW4pIDogdmFsdWU7XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9yc1xuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uWypdPSk6IFByb21pc2U8Ym9vbGVhbj59XG4gKi9cblxuXG5mdW5jdGlvbiBzeW5jQW5kKHZhbGlkYXRvcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZHVjZShmdW5jdGlvbiAodmFsaWQsIGZuKSB7XG4gICAgICBpZiAoIXVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHZhbGlkKSkgcmV0dXJuIHZhbGlkO1xuICAgICAgcmV0dXJuIHVud3JhcE5vcm1hbGl6ZWRWYWxpZGF0b3IoZm4pLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICB9LCB0cnVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXN5bmNBbmQodmFsaWRhdG9ycykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvcnMucmVkdWNlKGZ1bmN0aW9uICh2YWxpZCwgZm4pIHtcbiAgICAgIHJldHVybiBfYXdhaXQkMSh2YWxpZCwgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHIpID8gdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcihmbikuYXBwbHkoX3RoaXMyLCBhcmdzKSA6IHI7XG4gICAgICB9KTtcbiAgICB9LCBQcm9taXNlLnJlc29sdmUodHJ1ZSkpO1xuICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgd2hlbiBhbGwgdmFsaWRhdG9ycyBhcmUgdHJ1dGh5XG4gKiBAcGFyYW0gey4uLihOb3JtYWxpemVkVmFsaWRhdG9yIHwgRnVuY3Rpb24pfSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJuIHt7JHZhbGlkYXRvcjogZnVuY3Rpb24oLi4uWypdPSk6IChib29sZWFuIHwgUHJvbWlzZTxib29sZWFuPiksICRhc3luYzogYm9vbGVhbiwgJHdhdGNoVGFyZ2V0czogYW55W119fVxuICovXG5cblxuZnVuY3Rpb24gYW5kKCkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbGlkYXRvcnMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICB2YWxpZGF0b3JzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gIH1cblxuICB2YXIgJGFzeW5jID0gdmFsaWRhdG9ycy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYuJGFzeW5jO1xuICB9KTtcbiAgdmFyICR3YXRjaFRhcmdldHMgPSB2YWxpZGF0b3JzLnJlZHVjZShmdW5jdGlvbiAoYWxsLCB2KSB7XG4gICAgaWYgKCF2LiR3YXRjaFRhcmdldHMpIHJldHVybiBhbGw7XG4gICAgcmV0dXJuIGFsbC5jb25jYXQodi4kd2F0Y2hUYXJnZXRzKTtcbiAgfSwgW10pO1xuXG4gIHZhciAkdmFsaWRhdG9yID0gZnVuY3Rpb24gJHZhbGlkYXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoKSAkdmFsaWRhdG9yID0gJGFzeW5jID8gYXN5bmNBbmQodmFsaWRhdG9ycykgOiBzeW5jQW5kKHZhbGlkYXRvcnMpO1xuICByZXR1cm4ge1xuICAgICRhc3luYzogJGFzeW5jLFxuICAgICR2YWxpZGF0b3I6ICR2YWxpZGF0b3IsXG4gICAgJHdhdGNoVGFyZ2V0czogJHdhdGNoVGFyZ2V0c1xuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGlmIGFsbCB2YWxpZGF0b3JzIG1hdGNoLlxuICogQHBhcmFtIHsuLi4qfSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG5mdW5jdGlvbiBhbmQkMSAoKSB7XG4gIHJldHVybiB3aXRoUGFyYW1zKHtcbiAgICB0eXBlOiAnYW5kJ1xuICB9LCB3aXRoTWVzc2FnZSgnVGhlIHZhbHVlIGRvZXMgbm90IG1hdGNoIGFsbCBvZiB0aGUgcHJvdmlkZWQgdmFsaWRhdG9ycycsIGFuZC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykpKTtcbn1cblxuLyoqXG4gKiBTd2FwcyB0aGUgcmVzdWx0IG9mIGEgdmFsdWVcbiAqIEBwYXJhbSB7Tm9ybWFsaXplZFZhbGlkYXRvcnxGdW5jdGlvbn0gdmFsaWRhdG9yXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oKj0sICo9KTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBub3QgKHZhbGlkYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCB2bSkge1xuICAgIGlmICghcmVxKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHJlc3BvbnNlID0gdW53cmFwTm9ybWFsaXplZFZhbGlkYXRvcih2YWxpZGF0b3IpLmNhbGwodGhpcywgdmFsdWUsIHZtKTtcbiAgICBpZiAoIWlzUHJvbWlzZShyZXNwb25zZSkpIHJldHVybiAhdW53cmFwVmFsaWRhdG9yUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gIXVud3JhcFZhbGlkYXRvclJlc3BvbnNlKHIpO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIFN3YXBzIHRoZSByZXN1bHQgb2YgYSB2YWx1ZVxuICogQHBhcmFtIHtOb3JtYWxpemVkVmFsaWRhdG9yfEZ1bmN0aW9ufSB2YWxpZGF0b3JcbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG5vdCQxICh2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICAkdmFsaWRhdG9yOiBub3QodmFsaWRhdG9yKSxcbiAgICAkbWVzc2FnZTogXCJUaGUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIHByb3ZpZGVkIHZhbGlkYXRvclwiLFxuICAgICRwYXJhbXM6IHtcbiAgICAgIHR5cGU6ICdub3QnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlciB8IFJlZjxOdW1iZXI+IHwgUmVmPFN0cmluZz59IG1pblxuICogQHJldHVybnMge2Z1bmN0aW9uKCo9KTogYm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBtaW5WYWx1ZSAobWluKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gIXJlcSh2YWx1ZSkgfHwgKCEvXFxzLy50ZXN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICt2YWx1ZSA+PSArdW5yZWYobWluKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXIgfCBSZWY8TnVtYmVyPiB8IFJlZjxTdHJpbmc+fSBtaW5cbiAqIEByZXR1cm5zIHtOb3JtYWxpemVkVmFsaWRhdG9yfVxuICovXG5cbmZ1bmN0aW9uIG1pblZhbHVlJDEgKG1pbikge1xuICByZXR1cm4ge1xuICAgICR2YWxpZGF0b3I6IG1pblZhbHVlKG1pbiksXG4gICAgJG1lc3NhZ2U6IGZ1bmN0aW9uICRtZXNzYWdlKF9yZWYpIHtcbiAgICAgIHZhciAkcGFyYW1zID0gX3JlZi4kcGFyYW1zO1xuICAgICAgcmV0dXJuIFwiVGhlIG1pbmltdW0gdmFsdWUgYWxsb3dlZCBpcyBcIi5jb25jYXQoJHBhcmFtcy5taW4pO1xuICAgIH0sXG4gICAgJHBhcmFtczoge1xuICAgICAgbWluOiBtaW4sXG4gICAgICB0eXBlOiAnbWluVmFsdWUnXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICogQHBhcmFtIHtOdW1iZXIgfCBSZWY8TnVtYmVyPiB8IFJlZjxTdHJpbmc+fSBtYXhcbiAqIEByZXR1cm5zIHtmdW5jdGlvbigqPSk6IGJvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gbWF4VmFsdWUgKG1heCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuICFyZXEodmFsdWUpIHx8ICghL1xccy8udGVzdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiArdmFsdWUgPD0gK3VucmVmKG1heCk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKiBAcGFyYW0ge051bWJlciB8IFJlZjxOdW1iZXI+IHwgUmVmPFN0cmluZz59IG1heFxuICogQHJldHVybiB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgbWF4VmFsdWUkMSA9IChmdW5jdGlvbiAobWF4KSB7XG4gIHJldHVybiB7XG4gICAgJHZhbGlkYXRvcjogbWF4VmFsdWUobWF4KSxcbiAgICAkbWVzc2FnZTogZnVuY3Rpb24gJG1lc3NhZ2UoX3JlZikge1xuICAgICAgdmFyICRwYXJhbXMgPSBfcmVmLiRwYXJhbXM7XG4gICAgICByZXR1cm4gXCJUaGUgbWF4aW11bSB2YWx1ZSBpcyBcIi5jb25jYXQoJHBhcmFtcy5tYXgpO1xuICAgIH0sXG4gICAgJHBhcmFtczoge1xuICAgICAgbWF4OiBtYXgsXG4gICAgICB0eXBlOiAnbWF4VmFsdWUnXG4gICAgfVxuICB9O1xufSk7XG5cbi8vIF4tWzAtOV0rJCAtIG9ubHkgZm9yIG5lZ2F0aXZlIGludGVnZXIgKG1pbnVzIHNpZ24gd2l0aG91dCBhdCBsZWFzdCAxIGRpZ2l0IGlzIG5vdCBhIG51bWJlcilcblxudmFyIGludGVnZXIgPSByZWdleCgvKF5bMC05XSokKXwoXi1bMC05XSskKS8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGludGVnZXIuXG4gKiBAdHlwZSB7Tm9ybWFsaXplZFZhbGlkYXRvcn1cbiAqL1xuXG52YXIgaW50ZWdlciQxID0ge1xuICAkdmFsaWRhdG9yOiBpbnRlZ2VyLFxuICAkbWVzc2FnZTogJ1ZhbHVlIGlzIG5vdCBhbiBpbnRlZ2VyJyxcbiAgJHBhcmFtczoge1xuICAgIHR5cGU6ICdpbnRlZ2VyJ1xuICB9XG59O1xuXG52YXIgZGVjaW1hbCA9IHJlZ2V4KC9eWy1dP1xcZCooXFwuXFxkKyk/JC8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHZhbHVlIGlzIGRlY2ltYWwgbnVtYmVyLlxuICogQHR5cGUge05vcm1hbGl6ZWRWYWxpZGF0b3J9XG4gKi9cblxudmFyIGRlY2ltYWwkMSA9IHtcbiAgJHZhbGlkYXRvcjogZGVjaW1hbCxcbiAgJG1lc3NhZ2U6ICdWYWx1ZSBtdXN0IGJlIGRlY2ltYWwnLFxuICAkcGFyYW1zOiB7XG4gICAgdHlwZTogJ2RlY2ltYWwnXG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zbGF0YWJsZSB2ZXJzaW9uIG9mIGB3aXRoTWVzc2FnZWAgaGVscGVyLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdCAtIHRoZSB0cmFuc2xhdGlvbiBmdW5jdGlvbiBvZiB5b3VyIGNob2ljZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW21lc3NhZ2VQYXRoXSAtIGEgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIG1lc3NhZ2UgcGF0aCwgcGFzc2VkIHRvIGB0YCBmb3IgZWFjaCBtZXNzYWdlLiBCeSBkZWZhdWx0IGl0IGlzIGB2YWxpZGF0aW9ucy4keyR2YWxpZGF0b3J9YFxuICogQHBhcmFtIHtmdW5jdGlvbn0gW21lc3NhZ2VQYXJhbXNdIC0gYSBmdW5jdGlvbiB0byBhdWdtZW50IHRoZSBwYXJhbXMsIHBhc3NlZCB0byBgdGAgZm9yIGVhY2ggbWVzc2FnZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZShfcmVmKSB7XG4gIHZhciB0ID0gX3JlZi50LFxuICAgICAgX3JlZiRtZXNzYWdlUGF0aCA9IF9yZWYubWVzc2FnZVBhdGgsXG4gICAgICBtZXNzYWdlUGF0aCA9IF9yZWYkbWVzc2FnZVBhdGggPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciAkdmFsaWRhdG9yID0gX3JlZjIuJHZhbGlkYXRvcjtcbiAgICByZXR1cm4gXCJ2YWxpZGF0aW9ucy5cIi5jb25jYXQoJHZhbGlkYXRvcik7XG4gIH0gOiBfcmVmJG1lc3NhZ2VQYXRoLFxuICAgICAgX3JlZiRtZXNzYWdlUGFyYW1zID0gX3JlZi5tZXNzYWdlUGFyYW1zLFxuICAgICAgbWVzc2FnZVBhcmFtcyA9IF9yZWYkbWVzc2FnZVBhcmFtcyA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH0gOiBfcmVmJG1lc3NhZ2VQYXJhbXM7XG4gIHJldHVybiBmdW5jdGlvbiB3aXRoSTE4bk1lc3NhZ2UodmFsaWRhdG9yKSB7XG4gICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgX3JlZjMkd2l0aEFyZ3VtZW50cyA9IF9yZWYzLndpdGhBcmd1bWVudHMsXG4gICAgICAgIHdpdGhBcmd1bWVudHMgPSBfcmVmMyR3aXRoQXJndW1lbnRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJHdpdGhBcmd1bWVudHMsXG4gICAgICAgIF9yZWYzJG1lc3NhZ2VQYXRoID0gX3JlZjMubWVzc2FnZVBhdGgsXG4gICAgICAgIGxvY2FsTWVzc2FnZVBhdGggPSBfcmVmMyRtZXNzYWdlUGF0aCA9PT0gdm9pZCAwID8gbWVzc2FnZVBhdGggOiBfcmVmMyRtZXNzYWdlUGF0aCxcbiAgICAgICAgX3JlZjMkbWVzc2FnZVBhcmFtcyA9IF9yZWYzLm1lc3NhZ2VQYXJhbXMsXG4gICAgICAgIGxvY2FsTWVzc2FnZVBhcmFtcyA9IF9yZWYzJG1lc3NhZ2VQYXJhbXMgPT09IHZvaWQgMCA/IG1lc3NhZ2VQYXJhbXMgOiBfcmVmMyRtZXNzYWdlUGFyYW1zO1xuXG4gICAgZnVuY3Rpb24gbWVzc2FnZShwcm9wcykge1xuICAgICAgcmV0dXJuIHQobG9jYWxNZXNzYWdlUGF0aChwcm9wcyksIGxvY2FsTWVzc2FnZVBhcmFtcyhPYmplY3QuYXNzaWduKHtcbiAgICAgICAgbW9kZWw6IHByb3BzLiRtb2RlbCxcbiAgICAgICAgcHJvcGVydHk6IHByb3BzLiRwcm9wZXJ0eSxcbiAgICAgICAgcGVuZGluZzogcHJvcHMuJHBlbmRpbmcsXG4gICAgICAgIGludmFsaWQ6IHByb3BzLiRpbnZhbGlkLFxuICAgICAgICByZXNwb25zZTogcHJvcHMuJHJlc3BvbnNlLFxuICAgICAgICB2YWxpZGF0b3I6IHByb3BzLiR2YWxpZGF0b3IsXG4gICAgICAgIHByb3BlcnR5UGF0aDogcHJvcHMuJHByb3BlcnR5UGF0aFxuICAgICAgfSwgcHJvcHMuJHBhcmFtcykpKTtcbiAgICB9XG5cbiAgICBpZiAod2l0aEFyZ3VtZW50cyAmJiB0eXBlb2YgdmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2l0aE1lc3NhZ2UobWVzc2FnZSwgdmFsaWRhdG9yLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB3aXRoTWVzc2FnZShtZXNzYWdlLCB2YWxpZGF0b3IpO1xuICB9O1xufVxuXG5leHBvcnQgeyBhbHBoYSQxIGFzIGFscGhhLCBhbHBoYU51bSQxIGFzIGFscGhhTnVtLCBhbmQkMSBhcyBhbmQsIGJldHdlZW4kMSBhcyBiZXR3ZWVuLCBjcmVhdGVJMThuTWVzc2FnZSwgZGVjaW1hbCQxIGFzIGRlY2ltYWwsIGVtYWlsJDEgYXMgZW1haWwsIGNvbW1vbiBhcyBoZWxwZXJzLCBpbnRlZ2VyJDEgYXMgaW50ZWdlciwgaXBBZGRyZXNzJDEgYXMgaXBBZGRyZXNzLCBtYWNBZGRyZXNzJDEgYXMgbWFjQWRkcmVzcywgbWF4TGVuZ3RoJDEgYXMgbWF4TGVuZ3RoLCBtYXhWYWx1ZSQxIGFzIG1heFZhbHVlLCBtaW5MZW5ndGgkMSBhcyBtaW5MZW5ndGgsIG1pblZhbHVlJDEgYXMgbWluVmFsdWUsIG5vdCQxIGFzIG5vdCwgbnVtZXJpYyQxIGFzIG51bWVyaWMsIG9yJDEgYXMgb3IsIHJlcXVpcmVkJDEgYXMgcmVxdWlyZWQsIHJlcXVpcmVkSWYkMSBhcyByZXF1aXJlZElmLCByZXF1aXJlZFVubGVzcyQxIGFzIHJlcXVpcmVkVW5sZXNzLCBzYW1lQXMkMSBhcyBzYW1lQXMsIHVybCQxIGFzIHVybCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vuelidate/validators/dist/index.esm.js\n");

/***/ }),

/***/ "./node_modules/vue-demi/lib/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/vue-demi/lib/index.esm.js ***!
  \************************************************/
/*! exports provided: computed, createApp, createRef, customRef, defineAsyncComponent, defineComponent, del, getCurrentInstance, h, inject, isRaw, isReactive, isReadonly, isRef, markRaw, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onServerPrefetch, onUnmounted, onUpdated, provide, proxyRefs, reactive, readonly, ref, set, shallowReactive, shallowReadonly, shallowRef, toRaw, toRef, toRefs, triggerRef, unref, useCSSModule, useCssModule, warn, watch, watchEffect, Vue, Vue2, isVue2, isVue3, version, install */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vue2\", function() { return Vue2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVue2\", function() { return isVue2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVue3\", function() { return isVue3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"install\", function() { return install; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.common.js\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Vue\", function() { return vue__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/composition-api */ \"./node_modules/@vue/composition-api/dist/vue-composition-api.esm.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"computed\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"computed\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createApp\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"createApp\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"createRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"customRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"customRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineAsyncComponent\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"defineAsyncComponent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"defineComponent\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"defineComponent\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"del\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"del\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"getCurrentInstance\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"getCurrentInstance\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"h\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"inject\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"inject\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isRaw\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"isRaw\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isReactive\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"isReactive\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isReadonly\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"isReadonly\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"isRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"markRaw\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"markRaw\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"nextTick\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"nextTick\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onActivated\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onActivated\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onBeforeMount\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onBeforeMount\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onBeforeUnmount\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onBeforeUnmount\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onBeforeUpdate\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onBeforeUpdate\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onDeactivated\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onDeactivated\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onErrorCaptured\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onErrorCaptured\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onMounted\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onMounted\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onServerPrefetch\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onServerPrefetch\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onUnmounted\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onUnmounted\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"onUpdated\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"onUpdated\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"provide\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"provide\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"proxyRefs\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"proxyRefs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reactive\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"reactive\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"readonly\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"readonly\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ref\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"ref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"set\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shallowReactive\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"shallowReactive\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shallowReadonly\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"shallowReadonly\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"shallowRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"shallowRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toRaw\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"toRaw\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"toRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"toRefs\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"toRefs\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"triggerRef\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"triggerRef\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"unref\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"unref\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"useCSSModule\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"useCSSModule\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"useCssModule\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"useCssModule\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"warn\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"warn\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"watch\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"watch\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"watchEffect\", function() { return _vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"watchEffect\"]; });\n\n\n\n\nfunction install(_vue) {\n  _vue = _vue || vue__WEBPACK_IMPORTED_MODULE_0___default.a\n  if (_vue && !_vue['__composition_api_installed__'])\n    vue__WEBPACK_IMPORTED_MODULE_0___default.a.use(_vue_composition_api__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n}\n\ninstall(vue__WEBPACK_IMPORTED_MODULE_0___default.a)\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = vue__WEBPACK_IMPORTED_MODULE_0___default.a\nvar version = vue__WEBPACK_IMPORTED_MODULE_0___default.a.version\n\n/**VCA-EXPORTS**/\n\n/**VCA-EXPORTS**/\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWRlbWkvbGliL2luZGV4LmVzbS5qcz83MmRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXFCO0FBQytCOztBQUVwRDtBQUNBLGlCQUFpQiwwQ0FBRztBQUNwQjtBQUNBLElBQUksMENBQUcsS0FBSyw0REFBaUI7QUFDN0I7O0FBRUEsUUFBUSwwQ0FBRzs7QUFFWDtBQUNBO0FBQ0EsV0FBVywwQ0FBRztBQUNkLGNBQWMsMENBQUc7O0FBRWpCO0FBQ29DO0FBQ3BDOztBQVNDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1kZW1pL2xpYi9pbmRleC5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWVDb21wb3NpdGlvbkFQSSBmcm9tICdAdnVlL2NvbXBvc2l0aW9uLWFwaSdcblxuZnVuY3Rpb24gaW5zdGFsbChfdnVlKSB7XG4gIF92dWUgPSBfdnVlIHx8IFZ1ZVxuICBpZiAoX3Z1ZSAmJiAhX3Z1ZVsnX19jb21wb3NpdGlvbl9hcGlfaW5zdGFsbGVkX18nXSlcbiAgICBWdWUudXNlKFZ1ZUNvbXBvc2l0aW9uQVBJKVxufVxuXG5pbnN0YWxsKFZ1ZSlcblxudmFyIGlzVnVlMiA9IHRydWVcbnZhciBpc1Z1ZTMgPSBmYWxzZVxudmFyIFZ1ZTIgPSBWdWVcbnZhciB2ZXJzaW9uID0gVnVlLnZlcnNpb25cblxuLyoqVkNBLUVYUE9SVFMqKi9cbmV4cG9ydCAqIGZyb20gJ0B2dWUvY29tcG9zaXRpb24tYXBpJ1xuLyoqVkNBLUVYUE9SVFMqKi9cblxuZXhwb3J0IHtcbiAgVnVlLFxuICBWdWUyLFxuICBpc1Z1ZTIsXG4gIGlzVnVlMyxcbiAgdmVyc2lvbixcbiAgaW5zdGFsbCxcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-demi/lib/index.esm.js\n");

/***/ })

}]);